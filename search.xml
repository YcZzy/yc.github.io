<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数组去重的n种方法</title>
      <link href="2021/06/25/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>2021/06/25/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84n%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="方法1-（双重遍历）"><a href="#方法1-（双重遍历）" class="headerlink" title="方法1 （双重遍历）"></a>方法1 （双重遍历）</h2><h1 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h1><p>原理：第一层遍历数组，第二层再次遍历数组从i+1开始 当arr[i]===arr[j]的时候，删掉j，j–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  for (let j &#x3D; i + 1; j &lt; arr.length; j++) &#123;</span><br><span class="line">    if (arr[i] &#x3D;&#x3D;&#x3D; arr[j]) &#123;</span><br><span class="line">      arr.splice(j, 1)</span><br><span class="line">      &#x2F;&#x2F; 因为splice删除后 后面元素往前移动了，j要减一</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 2, 3, 5, 6, 4] </span><br></pre></td></tr></table></figure><h1 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h1><p>原理：设置个标志位，让源数组和去重后数组进行对比，如果相同则证明是重复的，标志位为true，如果没有则为false，把这个数放到去重后数组当中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr &#x3D; []</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (arr.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; i) &#123;</span><br><span class="line">    uniqueArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 5, 6, 4] </span><br></pre></td></tr></table></figure><h2 id="方法二（indexOf）"><a href="#方法二（indexOf）" class="headerlink" title="方法二（indexOf）"></a>方法二（indexOf）</h2><p>思路：indexof返回的下标和遍历的下标进行对比，如果相等证明没有，如果不等证明有重复的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr &#x3D; []</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (arr.indexOf(arr[i]) &#x3D;&#x3D;&#x3D; i) &#123;</span><br><span class="line">    uniqueArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 5, 6, 4] </span><br></pre></td></tr></table></figure><h2 id="方法三-（include）"><a href="#方法三-（include）" class="headerlink" title="方法三 （include）"></a>方法三 （include）</h2><p>思路：include返回布尔值，如果为true说明有重复的，如果为false放到数组中返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr &#x3D; []</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (!uniqueArr.includes(arr[i])) &#123;</span><br><span class="line">    uniqueArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 5, 6, 4] </span><br></pre></td></tr></table></figure><h2 id="方法四（set"><a href="#方法四（set" class="headerlink" title="方法四（set)"></a>方法四（set)</h2><p>思路：利用set函数，他内部的元素都是唯一的，没有重复值，再展开变成数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr&#x3D; [...new Set(arr)]</span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 5, 6, 4] </span><br></pre></td></tr></table></figure><h2 id="方法五（map）"><a href="#方法五（map）" class="headerlink" title="方法五（map）"></a>方法五（map）</h2><p>思路：用map的get和set方法，先get判断有没有，没有的set进去，之后push到数组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr &#x3D; []</span><br><span class="line">let map &#x3D; new Map()</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (!map.get(arr[i])) &#123;</span><br><span class="line">    map.set(arr[i], true)</span><br><span class="line">    uniqueArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 5, 6, 4]</span><br></pre></td></tr></table></figure><h2 id="方法六（hasOwnProperty）"><a href="#方法六（hasOwnProperty）" class="headerlink" title="方法六（hasOwnProperty）"></a>方法六（hasOwnProperty）</h2><p>思路：主要是利用对象的hasOwnProperty函数，如果对象存在有待检验的key，那么hasOwnProperty(key)就返回true,否则返回false。把数组的元素存进对象中，hasOwnProperty(元素)如果返回true, 则证明uniqueArr已经存在该元素了，无需再push了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr &#x3D; []</span><br><span class="line">let obj &#x3D; &#123;&#125;</span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if (!obj.hasOwnProperty(typeof arr[i] + arr[i])) &#123;</span><br><span class="line">    obj[typeof arr[i] + arr[i]] &#x3D; true</span><br><span class="line">    uniqueArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 5, 6, 4]</span><br></pre></td></tr></table></figure><h2 id="方法七（sort）"><a href="#方法七（sort）" class="headerlink" title="方法七（sort）"></a>方法七（sort）</h2><p>思路：排序后判断相邻的两个数是否相等，不相等push进数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr &#x3D; []</span><br><span class="line">arr.sort() </span><br><span class="line">for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">  if(arr[i] !&#x3D;&#x3D; arr[i + 1]) &#123;</span><br><span class="line">    uniqueArr.push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><h2 id="方法八（reduce）"><a href="#方法八（reduce）" class="headerlink" title="方法八（reduce）"></a>方法八（reduce）</h2><p>思路：主要是利用reduce函数，先排序，然后传入一个新数组，然后判断如果是新数组的length等于0 或者新数组的元素和遍历元素对比，如果不等就则push元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1, 2, 3, 3, 3, 2, 5, 5, 6, 4, 1]</span><br><span class="line">let uniqueArr &#x3D; arr.sort().reduce((acc, cur, i) &#x3D;&gt; &#123;</span><br><span class="line">  if (acc.length &#x3D;&#x3D;&#x3D; 0 || acc[acc.length - 1] !&#x3D;&#x3D; cur) &#123;</span><br><span class="line">    acc.push(cur)</span><br><span class="line">  &#125;</span><br><span class="line">  return acc</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line">console.log(uniqueArr) &#x2F;&#x2F; [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="2021/06/24/LeetCode/"/>
      <url>2021/06/24/LeetCode/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">/</th><th align="center">Title</th><th align="center">Explanation</th><th align="center">Difficulty</th><th align="center">Type</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><a href="https://leetcode.com/problems/two-sum/">two-sum</a></td><td align="center"><a href="https://yczzy.github.io/2021/06/24/two-sum/">Analyze</a></td><td align="center">Easy</td><td align="center">Array, Hash Table</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>two-sum</title>
      <link href="2021/06/24/two-sum/"/>
      <url>2021/06/24/two-sum/</url>
      
        <content type="html"><![CDATA[<h2 id="Title（Easy）"><a href="#Title（Easy）" class="headerlink" title="Title（Easy）"></a>Title（Easy）</h2><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例：</p><p><code>给定 nums = [2, 7, 11, 15], target = 9</code><br>因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]</p><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><p>题解1：暴力法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var twoSum &#x3D; function(nums,target)&#123;</span><br><span class="line">    var length &#x3D; nums.length;</span><br><span class="line">    for(var x&#x3D;0;x&lt;length;x++)&#123;</span><br><span class="line">        for(var y&#x3D;0;y&lt;length;y++)&#123;</span><br><span class="line">            if(nums[x]+nums[y]&#x3D;&#x3D;&#x3D;target)&#123;</span><br><span class="line">                var arr &#x3D; [];</span><br><span class="line">                arr.push(x);</span><br><span class="line">                arr.push(y);</span><br><span class="line">                return arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度O(n^2)<br>空间复杂度O(1)</p><p>题解2：哈希表</p><pre><code>思路：遍历一次数组，查询当前哈希表中是否有和当前索引值nums[i]随影的匹配值target-nums[i]    若有，则返回他们两个值的索引    若没有，则将当前索引值和下标存入哈希表中</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twoSum &#x3D; function (nums,target)&#123;</span><br><span class="line">    let numsObj&#x3D;&#123;&#125;;</span><br><span class="line">    for (let i&#x3D;0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        let current&#x3D;nums[i];</span><br><span class="line">        let match &#x3D; target-current;</span><br><span class="line">        if(match in numsObj)&#123;</span><br><span class="line">            return [i,numsObj[match]]</span><br><span class="line">        &#125;</span><br><span class="line">        numsObj[current] &#x3D; i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度: O(n)<br>空间复杂度: O(n)</p><p>题解3：使用 Map, 思路同哈希表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var twoSum &#x3D; function(nums, target) &#123;</span><br><span class="line">  var map &#x3D; new Map()</span><br><span class="line"></span><br><span class="line">  for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    const targetValue &#x3D; target - nums[i]</span><br><span class="line">    const getTargetValue &#x3D; map.get(targetValue)</span><br><span class="line">    if (typeof(getTargetValue) &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">      return [i, getTargetValue]</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(nums[i], i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题6</title>
      <link href="2021/04/27/%E7%AE%97%E6%B3%95%E9%A2%986/"/>
      <url>2021/04/27/%E7%AE%97%E6%B3%95%E9%A2%986/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-（困难）"><a href="#题目-（困难）" class="headerlink" title="题目 （困难）"></a>题目 （困难）</h2><p>整数中 1 出现的次数</p><p>求出 1<del>13 的整数中 1 出现的次数，并算出 100</del>1# 300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、<br>12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整<br>数区间中 1 出现的次数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这种题就要找规律，与之前做的那道找某个位置是什么数字的类似<br>现在有一个函数f(n)，代表n位上有多少个1<br>        f(0) = 0<br> 0<del>9    f(1) = 1<br> 0</del>99   f(2) = 10 + 10<em>f(1) = 20  (10+为  10<del>19中十位有10个1)<br> 0</del>999  f(3) = 100 + 10</em>f(2) = 300  (100+为  100<del>199中百位有100个1)<br> 10</del>9999 f(4) = 1000 + 10*f(3) = 4000 (…)<br>…<br>如 5467 中有多少个1</p><ol><li>0~5000中有 5 * f(3) + 1000 = 2500个</li><li>0~400中有 4 * f(2) + 100 = 180个</li><li>0~60中有 6 * f(1) + 10 = 16个</li><li>0~7中有 7 * f(0) + 1 = 1个<br>所以5467中有2697个1</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var countDigitOne &#x3D; function(n) &#123;</span><br><span class="line">    let f &#x3D; [0,1,20,300,4000,50000,600000,7000000,80000000,900000000,10000000000];</span><br><span class="line">    let res &#x3D; 0;</span><br><span class="line">    let str &#x3D; n + &#39;&#39;;</span><br><span class="line">    const len &#x3D; str.length;</span><br><span class="line">    let m &#x3D; Math.pow(10,len - 1);</span><br><span class="line">    let p &#x3D; len - 1; &#x2F;&#x2F;解析中的n</span><br><span class="line">    for(let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        res +&#x3D; str[i] * f[p];</span><br><span class="line">        if(str[i] &#x3D;&#x3D;&#x3D; &#39;1&#39; &amp;&amp; i !&#x3D;&#x3D; len - 1) &#123;&#x2F;&#x2F;中间为1时后面的每一个数都要加一个1，再加上第一个1，比如12中10，11,12三个数的十位有3个1，需要加上，也就是2+1个1要加上</span><br><span class="line">         res +&#x3D; Number(str.slice(i + 1)) + 1;</span><br><span class="line">        &#125; else if(str[i] &#x3D;&#x3D;&#x3D; &#39;1&#39; &amp;&amp; i &#x3D;&#x3D;&#x3D; len - 1) &#123;&#x2F;&#x2F;解决末尾为1但未加上的bug</span><br><span class="line">         res +&#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(str[i] &gt; 1) res +&#x3D; m;</span><br><span class="line">        m &#x2F;&#x3D; 10, p -&#x3D;1;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题5</title>
      <link href="2021/04/25/%E7%AE%97%E6%B3%95%E9%A2%985/"/>
      <url>2021/04/25/%E7%AE%97%E6%B3%95%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-（简单）"><a href="#题目-（简单）" class="headerlink" title="题目 （简单）"></a>题目 （简单）</h2><p>调整数组顺序使奇数位于偶数前面</p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半<br>部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后<br>面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判<br>断这个数可以经历多少次这样的过程</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @format</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不用看双指针  数组问题基本要想到双指针</span><br><span class="line">&#x2F;&#x2F; 双指针解法可以优化空间和时间 原地</span><br><span class="line">var exchange &#x3D; function (nums) &#123;</span><br><span class="line"> let front &#x3D; 0</span><br><span class="line"> let after &#x3D; 0</span><br><span class="line"> for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; 证明是偶数</span><br><span class="line">  if (nums[after] % 2 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; front &lt; nums.length) &#123;</span><br><span class="line">   while (nums[front] % 2 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    front++</span><br><span class="line">   &#125;</span><br><span class="line">   if (front &lt; nums.length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 交换</span><br><span class="line">    let temp &#x3D; nums[front]</span><br><span class="line">    nums[front] &#x3D; nums[after]</span><br><span class="line">    nums[after] &#x3D; temp</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  after++</span><br><span class="line">  front++</span><br><span class="line"> &#125;</span><br><span class="line"> return nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var exchange &#x3D; function(nums) &#123;</span><br><span class="line">    return nums.sort((a,b)&#x3D;&gt;b%2-a%2)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中几个优雅的运算符使用技巧</title>
      <link href="2021/04/25/JavaScript%E4%B8%AD%E5%87%A0%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>2021/04/25/JavaScript%E4%B8%AD%E5%87%A0%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="可选链接运算符【？-】"><a href="#可选链接运算符【？-】" class="headerlink" title="可选链接运算符【？.】"></a>可选链接运算符【？.】</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let data;</span><br><span class="line">console.log(data?.children?.[0]?.title) &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">data  &#x3D; &#123;children: [&#123;title:&#39;codercao&#39;&#125;]&#125;</span><br><span class="line">console.log(data?.children?.[0]?.title) &#x2F;&#x2F; codercao</span><br></pre></td></tr></table></figure><h3 id="对于方法的调用你可以这样写"><a href="#对于方法的调用你可以这样写" class="headerlink" title="对于方法的调用你可以这样写"></a>对于方法的调用你可以这样写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.runsOnlyIfMethodExists?.()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let parent &#x3D; &#123;</span><br><span class="line">    name: &quot;parent&quot;,</span><br><span class="line">    friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  parent.getName?.()   &#x2F;&#x2F; parent</span><br><span class="line">  parent.getTitle?.()  &#x2F;&#x2F;不会执行</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="与无效合并一起使用"><a href="#与无效合并一起使用" class="headerlink" title="与无效合并一起使用"></a>与无效合并一起使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let title &#x3D; data?.children?.[0]?.title ?? &#39;codercao&#39;;</span><br><span class="line">console.log(title); &#x2F;&#x2F; codercao</span><br></pre></td></tr></table></figure><h2 id="逻辑空分配（-）"><a href="#逻辑空分配（-）" class="headerlink" title="逻辑空分配（?? =）"></a>逻辑空分配（?? =）</h2><p>逻辑空值运算符仅在空值（空值或未定义）时才将值分配给expr1，表达方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr1 ??&#x3D; expr2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="逻辑或分配（-）"><a href="#逻辑或分配（-）" class="headerlink" title="逻辑或分配（|| =）"></a>逻辑或分配（|| =）</h2><p>此逻辑赋值运算符仅在左侧表达式为 falsy值时才赋值。Falsy与null有所不同，因为falsy可以是任何一种值：false，0，“”，null，undefined和NaN等</p><p>在我们想要保留现有值（如果不存在）的情况下，这很有用，否则我们想为其分配默认值。例如，如果搜索请求中没有数据，我们希望将元素的内部HTML设置为默认值。否则，我们要显示现有列表。这样，我们避免了不必要的更新和任何副作用，例如解析，重新渲染，失去焦点等。我们可以简单地使用此运算符来使用JavaScript更新HTML：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;search&#39;).innerHTML ||&#x3D; &#39;&lt;i&gt;No posts found matching this search.&lt;&#x2F;i&gt;&#39;</span><br></pre></td></tr></table></figure><h2 id="逻辑与分配（-amp-amp-）"><a href="#逻辑与分配（-amp-amp-）" class="headerlink" title="逻辑与分配（&amp;&amp; =）"></a>逻辑与分配（&amp;&amp; =）</h2><p>此逻辑赋值运算符仅在左侧为真时才赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp;&amp;&#x3D; y</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &amp;&amp; (x &#x3D; y)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题3</title>
      <link href="2021/04/22/%E7%AE%97%E6%B3%95%E9%A2%983/"/>
      <url>2021/04/22/%E7%AE%97%E6%B3%95%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-（简单）"><a href="#题目-（简单）" class="headerlink" title="题目 （简单）"></a>题目 （简单）</h2><p>跳台阶</p><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跳台阶是动态规划问题，由于一次只能跳1级或者2级，因此跳上n级台阶一共有2种方案，一种是从n-2跳上，一种是从n-1跳上</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numWays &#x3D; function (n) &#123;</span><br><span class="line">    if(n&lt;&#x3D;1) return 1;</span><br><span class="line">    if(n&#x3D;&#x3D;&#x3D;2) return 2;</span><br><span class="line">    return (numWays(n-1)+numWays(n-2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numWays &#x3D; function (n) &#123;</span><br><span class="line">    let p&#x3D;0,c&#x3D;1;</span><br><span class="line">    while (n--) [p,c] &#x3D; [c,(p+c)]</span><br><span class="line">    return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var numWays &#x3D; function(n) &#123; </span><br><span class="line">    let dp &#x3D; [];</span><br><span class="line">    dp[0] &#x3D; 1;</span><br><span class="line">    dp[1] &#x3D; 1;</span><br><span class="line">    for (let i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">      let c &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">      dp[i] &#x3D; c ;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题2</title>
      <link href="2021/04/21/%E7%AE%97%E6%B3%95%E9%A2%982/"/>
      <url>2021/04/21/%E7%AE%97%E6%B3%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h2 id="题目-（简单）"><a href="#题目-（简单）" class="headerlink" title="题目 （简单）"></a>题目 （简单）</h2><p>替换空格</p><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20<br>Are%20Happy</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.将字符串转换为数组，统计其中的空格数量</p><p>2.根据空格数量和原有长度计算出替换后的字符长度数组</p><p>3.创建2个指针，一个指末尾，一个指字符串有效位末尾，实现原地修改</p><p>数组遍历从后往前遍历，避免从前往后，造成字符串被修改</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var replaceSpace &#x3D; function (s) &#123;</span><br><span class="line">    s &#x3D; s.split(&quot;&quot;);</span><br><span class="line">    let oldLen &#x3D; s.length;</span><br><span class="line">    let spaceCount &#x3D; 0;</span><br><span class="line">    for(let i&#x3D;0;i&lt; oldLen; i++)&#123;</span><br><span class="line">        if(s[i]&#x3D;&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class="line">            spaceCount++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    s.length +&#x3D; spaceCount * 2;</span><br><span class="line">    for (let i &#x3D; oldLen-1,j&#x3D;s.length-1;i&gt;&#x3D;0;i--,j--)&#123;</span><br><span class="line">        if(s[i] !&#x3D;&#x3D; &#39; &#39;) s[j] &#x3D; s[i];</span><br><span class="line">        else &#123;</span><br><span class="line">            s[j-2]&#x3D;&#39;%&#39;;</span><br><span class="line">            s[j-1]&#x3D;&#39;2&#39;;</span><br><span class="line">            s[j]&#x3D;&#39;0&#39;;</span><br><span class="line">            j-&#x3D;2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return s.join(&#39;&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题1</title>
      <link href="2021/04/20/%E7%AE%97%E6%B3%95%E9%A2%981/"/>
      <url>2021/04/20/%E7%AE%97%E6%B3%95%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h2 id="题目（中等）"><a href="#题目（中等）" class="headerlink" title="题目（中等）"></a>题目（中等）</h2><p>二维数组中的查找</p><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的<br>一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.使用两层循环遍历，时间复杂度o(n^2)</p><p>2.利用递增的特定，可以从左上角开始遍历，当前数值比所求的值小，向右，当前数值比所求的值大，向上，时间复杂度o(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> var findNumber &#x3D; function(matrix,target)&#123;</span><br><span class="line">    if(!matrix.length) return false;</span><br><span class="line">    let x &#x3D; matrix.length - 1,y&#x3D;0;</span><br><span class="line">    while(x&gt;&#x3D;0;y &lt; matrix[0].length)&#123;</span><br><span class="line">        if(matrix[x][y] &#x3D;&#x3D;&#x3D; target)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else if (matrix[x][y] &gt; target)&#123;</span><br><span class="line">            x--</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            y++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 每日一题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="2021/04/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/04/14/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>你可能每天用到它许多次却不知道它。 每次你用谷歌或者必应搜索，它们很好用 是因为它们的机器学习软件已经计算出如何对网页排名 脸书或者苹果的照片应用在照片中识别出你的朋友， 这也是机器学习。 每次你阅读你的邮件 垃圾邮件过滤器把你从海量的垃圾邮件中解救出来， 这也是因为你的计算机学习了如何从非垃圾邮件中辨别垃圾邮件。 这就是机器学习。 这是一门是让计算机 无需显式编程 (explicitly programmed) 就能自主学习的学科。 我正在做的其中一个研究项目是让机器人去 整理房间。 你要怎样去做这个？ 你能做的是使机器人看你的演示任务和 从中学习。 机器人会看你拿起了什么东西，放在了哪里 试着去做同样的事情，即使在你不在的时候。 我对此感到兴奋的原因之一是 AI ，即 人工智能问题。 建立真正的智能机器， 就可以做任何你和我也能做的事情。 许多科学家认为在这方面取得进展的最好方法 是通过一种叫做神经网络的学习算法 这种算法模仿人类大脑的工作过程， 之后我也会教你。</p><h2 id="TensorFlow-js"><a href="#TensorFlow-js" class="headerlink" title="TensorFlow.js"></a>TensorFlow.js</h2><p>TensorFlow.js 是Google将机器学习(Machine Learning)TensorFlow框架的JavaScript版本，通过TensorFlow.js，让JavaScript开发人员也有机会加入机器学习的领域。加上前端领域的生态圈支持，让机器学习在浏览器上有了更多发挥的空间！例如结合摄影机、移动设备的陀螺仪等等，只要设备与浏览器支援，都能够发生更多不同的变化，同时借由在客户端浏览器上执行的优势，节省后端学习的成本。</p><h2 id="TensorFlow-js的特色与基本组成"><a href="#TensorFlow-js的特色与基本组成" class="headerlink" title="TensorFlow.js的特色与基本组成"></a>TensorFlow.js的特色与基本组成</h2><p>由于TensorFlow.js是由JavaScript编写而成，因此只要与浏览器相关的应用，都可以与TensorFlow.js直接整合，这意味着我们可以将浏览器功能与机器学习搭配起来，组合成更多元的Web Application。<br>TensorFlow.js也支持WebGL，因此即使在浏览器上，我们也能使用GPU来加速运算结果，不用担心在浏览器上的性能限制。<br>TensorFlow.js分成低阶与高阶两组API。<br>低阶的API是由 deeplearn.js 衍生，负责处理一些低阶如线性代数的数据运算等等，来协助我们处理机器学习中的数学运算部分。<br>而高阶的API则是用来包装一些常用的机器学习演算法，同时允许我们载入训练好的模型，像是由Keras学习的模型等等。</p><h2 id="机器学习基本概念"><a href="#机器学习基本概念" class="headerlink" title="机器学习基本概念"></a>机器学习基本概念</h2><p>先来简单讲讲一般机器学习是怎么做的，在机器学习中，通常我们会针对一个题目，给予一组学习数据清单，这些数据包含了问题与答案，接着通过机器学习的各种算法，来训练出一个针对这个题目的模型。<br>这个模型通常就代表了一个公式，只要将题目带进去公式，就能够算出答案，而这个公式怎么来的呢？就是通过机器学习算法，这些算法通常会先随机产生一个公式(也就是模型)，接着将学习数据带进去计算出预测值，并与正确答案比较，并通过不断的调整模型内容，不断想办法降低预测值与正确答案的差距，直到预测值与足够接近正确答案为止。<br>简单来说，就是经验法则啦！刚开始学一项知识的时候，得到的结果会与预期落差很大，借由不断学到正确知识后，就会与预期越来越接近！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="2021/03/08/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>2021/03/08/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><table><thead><tr><th>元素</th><th>Markdown语法</th></tr></thead><tbody><tr><td>标题</td><td># h1 <br> ## h2 <br> ### h3</td></tr><tr><td>粗体</td><td><code>**粗体**</code></td></tr><tr><td>斜体</td><td><code>*斜体*</code></td></tr><tr><td>引用块</td><td><code>&gt;引用块</code></td></tr><tr><td>有序列表</td><td><code>1. 列表1 2.列表2 3. 列表3</code></td></tr><tr><td>无序列表</td><td><code>- 列表1 - 列表2 - 列表3</code></td></tr><tr><td>代码</td><td><code>代码</code></td></tr><tr><td>分割线</td><td><code>---</code></td></tr><tr><td>链接</td><td><code>[title](https://www.example.com</code></td></tr><tr><td>图片</td><td><code>![alt text](image.jpg)</code></td></tr></tbody></table><h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><table><thead><tr><th>元素</th><th>Markdown语法</th></tr></thead><tbody><tr><td>表格</td><td></td></tr><tr><td>代码块</td><td><code>```代码块```</code></td></tr><tr><td>脚注</td><td><code>Here&#39;s a sentence with a footnote. [^1][^1]: This is the footnote.</code></td></tr><tr><td>标题编号</td><td><code>### My Great Heading &#123;#custom-id&#125;</code></td></tr><tr><td>定义列表</td><td><code>term: definition</code></td></tr><tr><td>删除线</td><td><code>~~删除线~~</code></td></tr><tr><td>任务列表</td><td><code>- [x] Write the press release - [ ] Update the website - [ ] Contact the media</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack打包后的代码是怎么样的</title>
      <link href="2021/03/08/webpack%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84/"/>
      <url>2021/03/08/webpack%E6%89%93%E5%8C%85%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack</span><br><span class="line"><span class="built_in">cd</span> webpack</span><br><span class="line">npm init -y</span><br><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>根目录中新建文件webpack.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    mode: &#39;development&#39;, &#x2F;&#x2F; 环境</span><br><span class="line">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,&#x2F;&#x2F; 入口</span><br><span class="line">    output: &#123;&#x2F;&#x2F;出口</span><br><span class="line">        filename: &#39;bundle.js&#39;,</span><br><span class="line">        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;)</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: &#39;cheap-source-map&#39;&#x2F;&#x2F; 为了更加方便查看输出</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在package.json中加入启动webpack的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个 src文件夹，新增 index.js 文件<br>执行yarn build</p><h2 id="分析主流程"><a href="#分析主流程" class="headerlink" title="分析主流程"></a>分析主流程</h2><h3 id="IFFE"><a href="#IFFE" class="headerlink" title="IFFE"></a>IFFE</h3><p>看输出的文件，整体上是一个IIFE(立即执行函数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function(modules) &#123; &#x2F;&#x2F; webpackBootstrap</span><br><span class="line">&#x2F;&#x2F; The module cache</span><br><span class="line">var installedModules &#x3D; &#123;&#125;;</span><br><span class="line">function __webpack_require__(moduleId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...省略细节</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 入口文件</span><br><span class="line">return __webpack_require__(__webpack_require__.s &#x3D; &quot;.&#x2F;src&#x2F;index.js&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line"></span><br><span class="line"> &quot;.&#x2F;src&#x2F;index.js&quot;: (function(module, __webpack_exports__, __webpack_require__) &#123;&#125;),</span><br><span class="line">  &quot;.&#x2F;src&#x2F;sayHello.js&quot;: (function(module, __webpack_exports__, __webpack_require__) &#123;&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>函数的入参modules是一个对象，对象的key就是每个js模块的相对路径，value就是模块函数。</p><p>IIFE会先require入口模块，然后入口模块会在执行时require其他模块，从而不断加载所需要的模块，形成依赖树</p><h3 id="重要的实现机制——-webpack-require"><a href="#重要的实现机制——-webpack-require" class="headerlink" title="重要的实现机制——__webpack_require__"></a>重要的实现机制——__webpack_require__</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 缓存模块使用</span><br><span class="line">var installedModules &#x3D; &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; The require function</span><br><span class="line">&#x2F;&#x2F; 模拟模块的加载，webpack 实现的 require</span><br><span class="line">function __webpack_require__(moduleId) &#123;</span><br><span class="line">  &#x2F;&#x2F; Check if module is in cache</span><br><span class="line">  &#x2F;&#x2F; 检查模块是否在缓存中，有则直接从缓存中获取</span><br><span class="line">  if(installedModules[moduleId]) &#123;</span><br><span class="line">    return installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; Create a new module (and put it into the cache)</span><br><span class="line">  &#x2F;&#x2F; 没有则创建并放入缓存中，其中 key 值就是模块 Id,也就是上面所说的文件路径</span><br><span class="line">  var module &#x3D; installedModules[moduleId] &#x3D; &#123;</span><br><span class="line">    i: moduleId, &#x2F;&#x2F; Module ID</span><br><span class="line">    l: false, &#x2F;&#x2F; 是否已经执行</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Execute the module function</span><br><span class="line">  &#x2F;&#x2F; 执行模块函数，挂载到 module.exports 上。this 指向 module.exports</span><br><span class="line">  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Flag the module as loaded</span><br><span class="line">  &#x2F;&#x2F; 标记这个 module 已经被加载</span><br><span class="line">  module.l &#x3D; true;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; Return the exports of the module</span><br><span class="line">  &#x2F;&#x2F; module.exports通过在执行module的时候，作为参数存进去，然后会保存module中暴露给外界的接口，如函数、变量等</span><br><span class="line">  return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步，webpack 这里做了一层优化，通过对象 installedModules 进行缓存，检查模块是否在缓存中，有则直接从缓存中获取，没有则创建并放入缓存中，其中 key 值就是模块 Id，也就是上面所说的文件路径</p><p>第二步，然后执行模块函数，将 module, module.exports, __webpack_require__ 作为参数传递，并把模块的函数调用对象指向 module.exports，保证模块中的 this 指向永远指向当前的模块。</p><p>第三步，最后返回加载的模块，调用方直接调用即可。</p><p>所以这个__webpack_require__就是来加载一个模块，并在最后返回模块 module.exports 变量</p><h3 id="webpack-是如何支持-ESM-的"><a href="#webpack-是如何支持-ESM-的" class="headerlink" title="webpack 是如何支持 ESM 的"></a>webpack 是如何支持 ESM 的</h3><h4 id="webpack-require-r-函数"><a href="#webpack-require-r-函数" class="headerlink" title="__webpack_require__.r 函数"></a>__webpack_require__.r 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.r &#x3D; (exports) &#x3D;&gt; &#123;</span><br><span class="line"> if(typeof Symbol !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; Symbol.toStringTag) &#123;</span><br><span class="line">        Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &#39;Module&#39; &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> Object.defineProperty(exports, &#39;__esModule&#39;, &#123; value: true &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>就是为__webpack_exports__ 添加__esModule属性 值为true</p><h4 id="webpack-require-n-函数"><a href="#webpack-require-n-函数" class="headerlink" title="__webpack_require__.n 函数"></a>__webpack_require__.n 函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.n &#x3D; (module) &#x3D;&gt; &#123;</span><br><span class="line"> var getter &#x3D; module &amp;&amp; module.__esModule ?</span><br><span class="line">        () &#x3D;&gt; (module[&#39;default&#39;]) :</span><br><span class="line">        () &#x3D;&gt; (module);</span><br><span class="line"> __webpack_require__.d(getter, &#123; a: getter &#125;);</span><br><span class="line"> return getter;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>__webpack_require__.n会判断modules是否为es模块，当__esModule为true时，标识module为es模块，默认返回module[‘default’]，否则返回module</p><h4 id="webpack-require-d"><a href="#webpack-require-d" class="headerlink" title="__webpack_require__.d"></a>__webpack_require__.d</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.d &#x3D; (exports, definition) &#x3D;&gt; &#123;</span><br><span class="line">for(var key in definition) &#123;</span><br><span class="line">if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) &#123;</span><br><span class="line">Object.defineProperty(exports, key, &#123; enumerable: true, get: definition[key] &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>__webpack_require__.d主要的工作就是将上面的 getter 函数绑定到 exports 中的属性 a 的 getter 上</p><p>打包后的模块函数。可以看出导出的是<strong>webpack_exports__[“default”]，实际上就是 __webpack_require</strong>.n 做了一层包装来实现的，其实也可以看出，实际上 webpack 是可以支持 CommonJS 和 ES Module 一起混用的</p><h2 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h2><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p><p>常见的代码分割有以下几种方法：</p><p>入口起点：使用 entry 配置手动地分离代码。<br>防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。<br>动态导入：通过模块的内联函数调用来分离代码。</p><h3 id="webpack-require-e-——使用-JSONP-动态加载"><a href="#webpack-require-e-——使用-JSONP-动态加载" class="headerlink" title="__webpack_require__.e ——使用 JSONP 动态加载"></a>__webpack_require__.e ——使用 JSONP 动态加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 已加载的chunk缓存</span><br><span class="line">var installedChunks &#x3D; &#123;</span><br><span class="line">  &quot;main&quot;: 0</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">__webpack_require__.e &#x3D; function requireEnsure(chunkId) &#123;</span><br><span class="line">  &#x2F;&#x2F; promises 队列，等待多个异步 chunk 都加载完成才执行回调</span><br><span class="line">  var promises &#x3D; [];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; JSONP chunk loading for javascript</span><br><span class="line">  var installedChunkData &#x3D; installedChunks[chunkId];</span><br><span class="line">  &#x2F;&#x2F; 0 代表已经 installed</span><br><span class="line">  if(installedChunkData !&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 0 means &quot;already installed&quot;.</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a Promise means &quot;currently loading&quot;.</span><br><span class="line">    &#x2F;&#x2F; 目标chunk正在加载，则将 promise push到 promises 数组</span><br><span class="line">    if(installedChunkData) &#123;</span><br><span class="line">      promises.push(installedChunkData[2]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; setup Promise in chunk cache</span><br><span class="line">      &#x2F;&#x2F; 利用Promise去异步加载目标chunk</span><br><span class="line">      var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置 installedChunks[chunkId]</span><br><span class="line">        installedChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br><span class="line">      &#125;);</span><br><span class="line">      &#x2F;&#x2F; i设置chunk加载的三种状态并缓存在 installedChunks 中，防止chunk重复加载</span><br><span class="line">      &#x2F;&#x2F; nstalledChunks[chunkId]  &#x3D; [resolve, reject, promise]</span><br><span class="line">      promises.push(installedChunkData[2] &#x3D; promise);</span><br><span class="line">      &#x2F;&#x2F; start chunk loading</span><br><span class="line">      &#x2F;&#x2F; 使用 JSONP</span><br><span class="line">      var head &#x3D; document.getElementsByTagName(&#39;head&#39;)[0];</span><br><span class="line">      var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line"></span><br><span class="line">      script.charset &#x3D; &#39;utf-8&#39;;</span><br><span class="line">      script.timeout &#x3D; 120;</span><br><span class="line"></span><br><span class="line">      if (__webpack_require__.nc) &#123;</span><br><span class="line">        script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 获取目标chunk的地址，__webpack_require__.p 表示设置的publicPath，默认为空串</span><br><span class="line">      script.src &#x3D; __webpack_require__.p + &quot;&quot; + chunkId + &quot;.bundle.js&quot;;</span><br><span class="line">      &#x2F;&#x2F; 请求超时的时候直接调用方法结束，时间为 120 s</span><br><span class="line">      var timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">        onScriptComplete(&#123; type: &#39;timeout&#39;, target: script &#125;);</span><br><span class="line">      &#125;, 120000);</span><br><span class="line">      script.onerror &#x3D; script.onload &#x3D; onScriptComplete;</span><br><span class="line">      &#x2F;&#x2F; 设置加载完成或者错误的回调</span><br><span class="line">      function onScriptComplete(event) &#123;</span><br><span class="line">        &#x2F;&#x2F; avoid mem leaks in IE.</span><br><span class="line">        &#x2F;&#x2F; 防止 IE 内存泄露</span><br><span class="line">        script.onerror &#x3D; script.onload &#x3D; null;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        var chunk &#x3D; installedChunks[chunkId];</span><br><span class="line">        &#x2F;&#x2F; 如果为 0 则表示已加载，主要逻辑看 webpackJsonpCallback 函数</span><br><span class="line">        if(chunk !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">          if(chunk) &#123;</span><br><span class="line">            var errorType &#x3D; event &amp;&amp; (event.type &#x3D;&#x3D;&#x3D; &#39;load&#39; ? &#39;missing&#39; : event.type);</span><br><span class="line">            var realSrc &#x3D; event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">            var error &#x3D; new Error(&#39;Loading chunk &#39; + chunkId + &#39; failed.\n(&#39; + errorType + &#39;: &#39; + realSrc + &#39;)&#39;);</span><br><span class="line">            error.type &#x3D; errorType;</span><br><span class="line">            error.request &#x3D; realSrc;</span><br><span class="line">            chunk[1](error);</span><br><span class="line">          &#125;</span><br><span class="line">          installedChunks[chunkId] &#x3D; undefined;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      head.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return Promise.all(promises);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出将 import() 转换成模拟 JSONP 去加载动态加载的 chunk 文件</p><p>设置 chunk 加载的三种状态并缓存在installedChunks中，防止chunk重复加载。这些状态的改变会在 webpackJsonpCallback 中提到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置 installedChunks[chunkId]</span><br><span class="line">installedChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br></pre></td></tr></table></figure><p>installedChunks[chunkId]为0，代表该 chunk 已经加载完毕<br>installedChunks[chunkId]为undefined，代表该 chunk 加载失败、加载超时、从未加载过<br>installedChunks[chunkId]为Promise对象，代表该 chunk 正在加载</p><p>看完__webpack_require__.e，我们知道的是，我们通过 JSONP 去动态引入 chunk 文件，并根据引入的结果状态进行处理，那么我们怎么知道引入之后的状态呢？我们来看异步加载的 chunk 是怎样的</p><h3 id="异步-Chunk"><a href="#异步-Chunk" class="headerlink" title="异步 Chunk"></a>异步 Chunk</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; window[&quot;webpackJsonp&quot;] 实际上是一个数组，向中添加一个元素。这个元素也是一个数组，其中数组的第一个元素是chunkId，第二个对象，跟传入到 IIFE 中的参数一样</span><br><span class="line">(window[&quot;webpackJsonp&quot;] &#x3D; window[&quot;webpackJsonp&quot;] || []).push([[0],&#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;***&#x2F; &quot;.&#x2F;src&#x2F;Another.js&quot;:</span><br><span class="line">  &#x2F;***&#x2F; (function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line">  </span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  __webpack_require__.r(__webpack_exports__);</span><br><span class="line">  &#x2F;* harmony export (binding) *&#x2F; __webpack_require__.d(__webpack_exports__, &quot;Another&quot;, function() &#123; return Another; &#125;);</span><br><span class="line">  function Another() &#123;</span><br><span class="line">    return &#39;Hi, I am Another Module&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;***&#x2F; &#125;)</span><br><span class="line">  </span><br><span class="line">  &#125;]);</span><br><span class="line">  &#x2F;&#x2F;# sourceMappingURL&#x3D;0.bundle.js.map</span><br></pre></td></tr></table></figure><p>主要做的事情就是往一个数组 window[‘webpackJsonp’] 中塞入一个元素，这个元素也是一个数组，其中数组的第一个元素是 chunkId，第二个对象，跟主 chunk 中 IIFE 传入的参数类似。关键是这个 window[‘webpackJsonp’] 在哪里会用到呢？我们回到主 chunk 中。在 return <strong>webpack_require__(__webpack_require</strong>.s = “./src/index.js”); 进入入口之前还有一段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var jsonpArray &#x3D; window[&quot;webpackJsonp&quot;] &#x3D; window[&quot;webpackJsonp&quot;] || [];</span><br><span class="line">&#x2F;&#x2F; 保存原始的 Array.prototype.push 方法</span><br><span class="line">var oldJsonpFunction &#x3D; jsonpArray.push.bind(jsonpArray);</span><br><span class="line">&#x2F;&#x2F; 将 push 方法的实现修改为 webpackJsonpCallback</span><br><span class="line">&#x2F;&#x2F; 这样我们在异步 chunk 中执行的 window[&#39;webpackJsonp&#39;].push 其实是 webpackJsonpCallback 函数。</span><br><span class="line">jsonpArray.push &#x3D; webpackJsonpCallback;</span><br><span class="line">jsonpArray &#x3D; jsonpArray.slice();</span><br><span class="line">&#x2F;&#x2F; 对已在数组中的元素依次执行webpackJsonpCallback方法</span><br><span class="line">for(var i &#x3D; 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class="line">var parentJsonpFunction &#x3D; oldJsonpFunction;</span><br></pre></td></tr></table></figure><p>jsonpArray 就是 window[“webpackJsonp”] ，重点看下面这一句代码，当执行 push 方法的时候，就会执行 webpackJsonpCallback，相当于做了一层劫持，也就是执行完 push 操作的时候就会调用这个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsonpArray.push &#x3D; webpackJsonpCallback;</span><br></pre></td></tr></table></figure><p>webpackJsonpCallback ——加载完动态 chunk 之后的回调<br>我们再来看看  webpackJsonpCallback 函数，这里的入参就是动态加载的 chunk 的 window[‘webpackJsonp’] push 进去的参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var installedChunks &#x3D; &#123;</span><br><span class="line">  &quot;main&quot;: 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function webpackJsonpCallback(data) &#123;</span><br><span class="line">  &#x2F;&#x2F; window[&quot;webpackJsonp&quot;] 中的第一个参数——即[0]</span><br><span class="line">  var chunkIds &#x3D; data[0];</span><br><span class="line">  &#x2F;&#x2F; 对应的模块详细信息，详见打包出来的 chunk 模块中的 push 进 window[&quot;webpackJsonp&quot;] 中的第二个参数</span><br><span class="line">  var moreModules &#x3D; data[1];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; add &quot;moreModules&quot; to the modules object,</span><br><span class="line">  &#x2F;&#x2F; then flag all &quot;chunkIds&quot; as loaded and fire callback</span><br><span class="line">  var moduleId, chunkId, i &#x3D; 0, resolves &#x3D; [];</span><br><span class="line">  for(;i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">    chunkId &#x3D; chunkIds[i];</span><br><span class="line">    &#x2F;&#x2F; 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]</span><br><span class="line">    &#x2F;&#x2F; 这个可以看 __webpack_require__.e 中设置的状态</span><br><span class="line">    &#x2F;&#x2F; 表示正在执行的chunk，加入到 resolves 数组中</span><br><span class="line">    if(installedChunks[chunkId]) &#123;</span><br><span class="line">      resolves.push(installedChunks[chunkId][0]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 标记成已经执行完</span><br><span class="line">    installedChunks[chunkId] &#x3D; 0;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中</span><br><span class="line">  for(moduleId in moreModules) &#123;</span><br><span class="line">    if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">      modules[moduleId] &#x3D; moreModules[moduleId];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; parentJsonpFunction: 原始的数组 push 方法，将 data 加入 window[&quot;webpackJsonp&quot;] 数组。</span><br><span class="line">  if(parentJsonpFunction) parentJsonpFunction(data);</span><br><span class="line">  &#x2F;&#x2F; 等到 while 循环结束后，__webpack_require__.e 的返回值 Promise 得到 resolve</span><br><span class="line">  &#x2F;&#x2F; 执行 resolove</span><br><span class="line">  while(resolves.length) &#123;</span><br><span class="line">    resolves.shift()();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们 JSONP 去加载异步 chunk 完成之后，就会去执行 window[“webpackJsonp”] || []).push，也就是 webpackJsonpCallback。主要有以下几步</p><p>遍历要加载的 chunkIds，找到未执行完的 chunk，并加入到 resolves 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for(;i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">  chunkId &#x3D; chunkIds[i];</span><br><span class="line">  &#x2F;&#x2F; 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]</span><br><span class="line">  &#x2F;&#x2F; 这个可以看 __webpack_require__.e 中设置的状态</span><br><span class="line">  &#x2F;&#x2F; 表示正在执行的chunk，加入到 resolves 数组中</span><br><span class="line">  if(installedChunks[chunkId]) &#123;</span><br><span class="line">    resolves.push(installedChunks[chunkId][0]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 标记成已经执行完</span><br><span class="line">  installedChunks[chunkId] &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里未执行的是非 0 状态，执行完就设置为0</p><p>installedChunks[chunkId][0] 实际上就是 Promise 构造函数中的 resolve</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __webpack_require__.e </span><br><span class="line">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">installedChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中</p><p>原始的数组 push 方法，将 data 加入 window[“webpackJsonp”] 数组</p><p>执行各个 resolves 方法，告诉 __webpack_require__.e 中回调函数的状态</p><p>只有当这个方法执行完成的时候，我们才知道 JSONP 成功与否，也就是script.onload/onerror 会在 webpackJsonpCallback 之后执行。所以 onload/onerror 其实是用来检查 webpackJsonpCallback 的完成度：有没有将 installedChunks 中对应的 chunk 值设为 0</p><p>大致的流程如下图所示</p><p><a href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/234b9478b2764bddbeee6c539d85c4ff~tplv-k3u1fbpfcp-zoom-1.image">image.jpg</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
