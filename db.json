{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/Butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/avatar.jpeg","path":"img/avatar.jpeg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/bg.jpeg","path":"img/bg.jpeg","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/Butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Markdown语法.md","hash":"358423bc5baf3d3ba576d8a4ee64754b73555d35","modified":1619160308621},{"_id":"source/_posts/算法题1.md","hash":"8c1b125d7f75d5868b1a70e4b291df48f57fc8e7","modified":1619160308622},{"_id":"source/_posts/JavaScript中几个优雅的运算符使用技巧.md","hash":"9adc32a78a8ee48e4fa32626038620d1d5e47ed3","modified":1619330018892},{"_id":"source/_posts/webpack打包后的代码是怎么样的.md","hash":"6d080c7cbc277d89020d50c8a222b148810e267b","modified":1619440475987},{"_id":"source/_posts/算法题3.md","hash":"3f4bbe22e70a46e3f6b404a374ccaaeeff143bc3","modified":1619160308622},{"_id":"source/_posts/机器学习.md","hash":"4fd165967decd937221d410065b4c296ae980fad","modified":1619160308622},{"_id":"source/_posts/算法题2.md","hash":"97d09da1a9032570fe0c4d517af792a8ce39b3ee","modified":1619160308622},{"_id":"source/_posts/算法题4.md","hash":"3d500a280447b6b7124cf6d8caf1c6210e966ada","modified":1619181515515},{"_id":"source/_posts/算法题5.md","hash":"757b96820bcb3a399f99dc979c981a1f9faef244","modified":1619354459933},{"_id":"source/categories/index.md","hash":"26d6478f94313a02aa85d9d8bf6e585d06677033","modified":1619160308622},{"_id":"source/tags/index.md","hash":"e3216010f28af170bb11bbde7f6610116dd4f35c","modified":1619160308622},{"_id":"source/_posts/算法题6.md","hash":"f370385e2899b6be5ec505edb5b5f0e03d7e9bd4","modified":1619527436289},{"_id":"themes/Butterfly/README.md","hash":"6fb49415adfefe85efc530cfb0a74dadb0bd1159","modified":1619160730194},{"_id":"themes/Butterfly/package.json","hash":"e1bbac0d82813ead6a4666e2c7b4a877bf429f5b","modified":1619160730272},{"_id":"themes/Butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1619160730194},{"_id":"themes/Butterfly/README_CN.md","hash":"605ae2826b86f304cffc14db8898d1af0790dedc","modified":1619160730195},{"_id":"themes/Butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1619160730191},{"_id":"themes/Butterfly/_config.yml","hash":"bad7618f9de724b315fd1e52bf8d48e803e1715d","modified":1619160730197},{"_id":"themes/Butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1619160730198},{"_id":"themes/Butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1619160730199},{"_id":"themes/Butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1619160730199},{"_id":"themes/Butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1619160730200},{"_id":"themes/Butterfly/layout/404.pug","hash":"58cfa5985e58e10c97a9f8a9dc354f1c766154b3","modified":1619160730202},{"_id":"themes/Butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1619160730203},{"_id":"themes/Butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1619160730269},{"_id":"themes/Butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1619160730204},{"_id":"themes/Butterfly/layout/page.pug","hash":"58d0f81279a52fe060560a2ede825beafc44fe93","modified":1619160730270},{"_id":"themes/Butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1619160730271},{"_id":"themes/Butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1619160730271},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1619160730189},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1619160730190},{"_id":"themes/Butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1619160730190},{"_id":"themes/Butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1619160730192},{"_id":"themes/Butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1619160730205},{"_id":"themes/Butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1619160730206},{"_id":"themes/Butterfly/layout/includes/head.pug","hash":"aa105ea4eaecc951f7474b549b6ac0095a5fab1f","modified":1619160730211},{"_id":"themes/Butterfly/layout/includes/layout.pug","hash":"76d672c91f6bb6f20c6936e05067c42f7917ac61","modified":1619160730216},{"_id":"themes/Butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1619160730273},{"_id":"themes/Butterfly/scripts/events/init.js","hash":"43b245c308797c2d62cb70429a85f1a05d3395ab","modified":1619160730274},{"_id":"themes/Butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1619160730274},{"_id":"themes/Butterfly/scripts/filters/post_lazyload.js","hash":"e9cf275c362d8634f093e63068da7ed1e53c7600","modified":1619160730275},{"_id":"themes/Butterfly/scripts/filters/random_cover.js","hash":"0f5017be123ae2b2ddf231d9d71a5c4cd1f2f206","modified":1619160730276},{"_id":"themes/Butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1619160730277},{"_id":"themes/Butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1619160730277},{"_id":"themes/Butterfly/scripts/helpers/inject_head_js.js","hash":"81459adf885a15c6e9784bc2275c07efe67ab0b4","modified":1619160730278},{"_id":"themes/Butterfly/scripts/helpers/page.js","hash":"1da73cd47b78c6dbc3f04ce500d6cc5711c94412","modified":1619160730280},{"_id":"themes/Butterfly/scripts/helpers/related_post.js","hash":"0d8ba6120dce617a2a1fbc9167572db2ee9f22ef","modified":1619160730281},{"_id":"themes/Butterfly/layout/includes/pagination.pug","hash":"a3298d12181d739dedd2ea20b65594797e42e6d7","modified":1619160730222},{"_id":"themes/Butterfly/scripts/tag/button.js","hash":"e75283267f3a4773e6d803593d557e218396f260","modified":1619160730282},{"_id":"themes/Butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1619160730283},{"_id":"themes/Butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1619160730284},{"_id":"themes/Butterfly/layout/includes/sidebar.pug","hash":"f81b25dfabfa50e76acd100b97774936179ad85f","modified":1619160730225},{"_id":"themes/Butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1619160730285},{"_id":"themes/Butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1619160730285},{"_id":"themes/Butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1619160730286},{"_id":"themes/Butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1619160730224},{"_id":"themes/Butterfly/source/_data/valine.json","hash":"1a1c458d772ee03aba5efa03f357e9097068cb4e","modified":1619160730288},{"_id":"themes/Butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1619160730336},{"_id":"themes/Butterfly/source/css/var.styl","hash":"e92eaefda462315051872b7894a6f6eb70a29006","modified":1619160730337},{"_id":"themes/Butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1619160730338},{"_id":"themes/Butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1619160730339},{"_id":"themes/Butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1619160730343},{"_id":"themes/Butterfly/source/img/bg.jpeg","hash":"b3eb44c8a859a60adf6902f6c30ab7870c1b1e43","modified":1619160730342},{"_id":"themes/Butterfly/source/js/main.js","hash":"8cf2fb897890fa5fbbffbe936d6fa80b383584d9","modified":1619160730348},{"_id":"themes/Butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1619160730345},{"_id":"themes/Butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1619160730346},{"_id":"themes/Butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1619160730207},{"_id":"themes/Butterfly/layout/includes/head/config.pug","hash":"d43e7209864627a06b06879867d51841025ab9ee","modified":1619160730208},{"_id":"themes/Butterfly/layout/includes/head/Open_Graph.pug","hash":"5390f2aea030486bf78678b910bda177b0ba5d05","modified":1619160730207},{"_id":"themes/Butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1619160730353},{"_id":"themes/Butterfly/layout/includes/head/config_site.pug","hash":"798dbbe9146e8e2379b39a49acf8c8a1eeabb8fb","modified":1619160730208},{"_id":"themes/Butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1619160730209},{"_id":"themes/Butterfly/source/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1619160730354},{"_id":"themes/Butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1619160730210},{"_id":"themes/Butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1619160730209},{"_id":"themes/Butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1619160730210},{"_id":"themes/Butterfly/layout/includes/head/site_verification.pug","hash":"62cf37e28795d8b68a0e850ec8c94987b9e08db5","modified":1619160730211},{"_id":"themes/Butterfly/layout/includes/header/index.pug","hash":"c8e3d8944ced189ac27a20e2853735b44eb9cab3","modified":1619160730212},{"_id":"themes/Butterfly/layout/includes/header/nav.pug","hash":"0a8b0b3d82bef350fea5b42b1f69dbb6551b8627","modified":1619160730214},{"_id":"themes/Butterfly/layout/includes/header/post-info.pug","hash":"136fb938ace9904f7f68725fcb543312ccfeef2c","modified":1619160730214},{"_id":"themes/Butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1619160730215},{"_id":"themes/Butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1619160730217},{"_id":"themes/Butterfly/layout/includes/mixins/article-sort.pug","hash":"68dfd3c6a0f00b3ffc0333c81e165b4626f7425f","modified":1619160730218},{"_id":"themes/Butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1619160730217},{"_id":"themes/Butterfly/layout/includes/header/menu_item.pug","hash":"14cd0f9c0c578512896b487263cd48570d74771a","modified":1619160730213},{"_id":"themes/Butterfly/layout/includes/page/artitalk.pug","hash":"2a435df727ba4a0e6678c06c1b4b83745dfef841","modified":1619160730220},{"_id":"themes/Butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1619160730220},{"_id":"themes/Butterfly/layout/includes/mixins/post-ui.pug","hash":"6058de23612ab1ed17d2ad93f5866d5f745135f0","modified":1619160730218},{"_id":"themes/Butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1619160730221},{"_id":"themes/Butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1619160730224},{"_id":"themes/Butterfly/layout/includes/page/flink.pug","hash":"45f0d36b1ac686b5984909dae55d3c522f549c3a","modified":1619160730221},{"_id":"themes/Butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1619160730222},{"_id":"themes/Butterfly/layout/includes/post/reward.pug","hash":"edebe930a2e3c4a4de5a35b9c1b1409cdd401372","modified":1619160730224},{"_id":"themes/Butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1619160730226},{"_id":"themes/Butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1619160730246},{"_id":"themes/Butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1619160730255},{"_id":"themes/Butterfly/layout/includes/third-party/pjax.pug","hash":"5b61b65dd030aed0cd2446549cf150ecdac49156","modified":1619160730256},{"_id":"themes/Butterfly/layout/includes/third-party/subtitle.pug","hash":"50f0574a1db1c62d56042b10880ba348d65d8fd9","modified":1619160730262},{"_id":"themes/Butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1619160730256},{"_id":"themes/Butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1619160730263},{"_id":"themes/Butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1619160730264},{"_id":"themes/Butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1619160730263},{"_id":"themes/Butterfly/layout/includes/widget/card_author.pug","hash":"64bd872377d190966727668a00b156a8b3d95da3","modified":1619160730264},{"_id":"themes/Butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1619160730265},{"_id":"themes/Butterfly/layout/includes/widget/card_newest_comment.pug","hash":"36b368516b5a746be84a6aa08767ee24d220d509","modified":1619160730265},{"_id":"themes/Butterfly/layout/includes/widget/card_recent_post.pug","hash":"e356f916ceb28702812d8f66c1fea0ae75eece47","modified":1619160730266},{"_id":"themes/Butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1619160730266},{"_id":"themes/Butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1619160730268},{"_id":"themes/Butterfly/layout/includes/widget/card_self.pug","hash":"a1b2f5575b6804c5c4b9288db143b5164cbbd289","modified":1619160730267},{"_id":"themes/Butterfly/layout/includes/widget/card_tags.pug","hash":"1c9652cf71da32414a79b0ea6704421a59bdce2e","modified":1619160730267},{"_id":"themes/Butterfly/layout/includes/widget/index.pug","hash":"9e91f2543ab39815309268d07ae248a78887acf9","modified":1619160730268},{"_id":"themes/Butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1619160730290},{"_id":"themes/Butterfly/source/css/_global/index.styl","hash":"6ba9dcda7ff1ceda4e07c8c08517259e8b7dbcd5","modified":1619160730291},{"_id":"themes/Butterfly/source/css/_highlight/highlight.styl","hash":"3305ab95795801339bc515affca56c11ddc954e6","modified":1619160730295},{"_id":"themes/Butterfly/source/css/_layout/404.styl","hash":"d6548e332e6e57e2a7ba2eb53cdd838c3cd1846d","modified":1619160730301},{"_id":"themes/Butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1619160730304},{"_id":"themes/Butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1619160730300},{"_id":"themes/Butterfly/source/css/_layout/aside.styl","hash":"32008b58a76f486854b242ad686d4151bc54bbd6","modified":1619160730303},{"_id":"themes/Butterfly/source/css/_layout/head.styl","hash":"cb1770e1dfc82ad5fb5ef3dc7f5fa7a5b0dc3297","modified":1619160730309},{"_id":"themes/Butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1619160730304},{"_id":"themes/Butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1619160730310},{"_id":"themes/Butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1619160730306},{"_id":"themes/Butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1619160730310},{"_id":"themes/Butterfly/source/css/_layout/post.styl","hash":"3b5ed196e64a0bbd0f93d82dd85a7f3a27c9ec9e","modified":1619160730311},{"_id":"themes/Butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1619160730312},{"_id":"themes/Butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1619160730313},{"_id":"themes/Butterfly/source/css/_layout/third-party.styl","hash":"788a28f68e29fad5328dc03be2f3268324281652","modified":1619160730316},{"_id":"themes/Butterfly/source/css/_layout/sidebar.styl","hash":"7a6e1f21173022a3a1f18a62785cdd657a1af0a1","modified":1619160730315},{"_id":"themes/Butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1619160730315},{"_id":"themes/Butterfly/source/css/_mode/darkmode.styl","hash":"b59ae684b5baeb5efc7f5ccd053dca768a009ebf","modified":1619160730317},{"_id":"themes/Butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1619160730320},{"_id":"themes/Butterfly/source/css/_page/common.styl","hash":"a6f8637e90e44e23338209d4a3438e3e67766971","modified":1619160730321},{"_id":"themes/Butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1619160730319},{"_id":"themes/Butterfly/source/css/_page/flink.styl","hash":"d60b7a94a7adeac489b8c1afdf7e679994829742","modified":1619160730322},{"_id":"themes/Butterfly/source/css/_mode/readmode.styl","hash":"4dbf1ecdd9837fa77bc8ba9739b62ff704dfda69","modified":1619160730318},{"_id":"themes/Butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1619160730323},{"_id":"themes/Butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1619160730323},{"_id":"themes/Butterfly/source/css/_search/algolia.styl","hash":"6b05ca4409d2dc09e123af4e0af9f9d0f7142b73","modified":1619160730324},{"_id":"themes/Butterfly/source/css/_search/index.styl","hash":"89e744abc5e41f4855e7b87b13b854f4ec4ffc0e","modified":1619160730325},{"_id":"themes/Butterfly/source/css/_search/local-search.styl","hash":"51f2bd03a2d0787911d0c090fb555a664b3fac8b","modified":1619160730326},{"_id":"themes/Butterfly/source/css/_tags/button.styl","hash":"a7fc7624a8d893bdf9444f14154484c29c790e99","modified":1619160730327},{"_id":"themes/Butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1619160730329},{"_id":"themes/Butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1619160730331},{"_id":"themes/Butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1619160730330},{"_id":"themes/Butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1619160730332},{"_id":"themes/Butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1619160730333},{"_id":"themes/Butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1619160730335},{"_id":"themes/Butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1619160730352},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1619160730227},{"_id":"themes/Butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1619160730351},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1619160730228},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1619160730228},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1619160730229},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1619160730229},{"_id":"themes/Butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"76c061a16d7e5935f02acd27c6cdb4933c642b97","modified":1619160730231},{"_id":"themes/Butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1619160730232},{"_id":"themes/Butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1619160730233},{"_id":"themes/Butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1619160730234},{"_id":"themes/Butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1619160730235},{"_id":"themes/Butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1619160730236},{"_id":"themes/Butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1619160730236},{"_id":"themes/Butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f617cacf5d1e8335abba96ee1ce4b79c17411e1e","modified":1619160730238},{"_id":"themes/Butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b2fb4af74d54f1daa39d4afc321d38a2a72e0ddd","modified":1619160730239},{"_id":"themes/Butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"353ebd0bdecdfde6dee32c3aa208cc87c72b15c0","modified":1619160730239},{"_id":"themes/Butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"99dbf2b87b372f07315a3b879a77131eaf3da066","modified":1619160730240},{"_id":"themes/Butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1619160730241},{"_id":"themes/Butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1619160730242},{"_id":"themes/Butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"881618ffb26b13ad6276a65e34846e6bda2145cb","modified":1619160730243},{"_id":"themes/Butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1619160730242},{"_id":"themes/Butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1619160730244},{"_id":"themes/Butterfly/layout/includes/third-party/comments/valine.pug","hash":"5b015bb6fc61d136512f78aa4e3bc3165afb9cf2","modified":1619160730244},{"_id":"themes/Butterfly/layout/includes/third-party/comments/waline.pug","hash":"544fb85361c61dffc39a87e808d8bda04cfd863f","modified":1619160730245},{"_id":"themes/Butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1619160730248},{"_id":"themes/Butterfly/layout/includes/third-party/math/katex.pug","hash":"21b7ec96c606823d3d72e72775495ef77502b4cb","modified":1619160730249},{"_id":"themes/Butterfly/layout/includes/third-party/math/mathjax.pug","hash":"4afc12ce42d067fa4012039aa444343a36f73599","modified":1619160730249},{"_id":"themes/Butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1619160730250},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"9820d731bb66a1d9c2e0083361d0c99c68c93fdf","modified":1619160730252},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"a13246714c9b9c6d6e5093f131a57bb49d653940","modified":1619160730253},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"18dcf05ab58107bbff426376aef2577f59583fc2","modified":1619160730253},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1619160730254},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1619160730255},{"_id":"themes/Butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"9657b1b08ff3f98e49ca250ed47a81b8b202ac7a","modified":1619160730255},{"_id":"themes/Butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1619160730257},{"_id":"themes/Butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1619160730258},{"_id":"themes/Butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1619160730258},{"_id":"themes/Butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1619160730259},{"_id":"themes/Butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1619160730260},{"_id":"themes/Butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1619160730261},{"_id":"themes/Butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1619160730261},{"_id":"themes/Butterfly/source/css/_highlight/highlight/diff.styl","hash":"3bcd66576d13db8f93fa5b799a973d55e060a708","modified":1619160730293},{"_id":"themes/Butterfly/source/css/_highlight/highlight/index.styl","hash":"52c63a50a37fa315753e72b3661676156aeae794","modified":1619160730294},{"_id":"themes/Butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1619160730297},{"_id":"themes/Butterfly/source/css/_highlight/prismjs/index.styl","hash":"897a18a82c0cad141b3ed9e2f1b4af60c24c334b","modified":1619160730298},{"_id":"themes/Butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"d40f1baec16c4a62e4a3a9a0379d1ca3ac6746b2","modified":1619160730299},{"_id":"themes/Butterfly/source/img/avatar.jpeg","hash":"9211fe14e648515a8f7d5c7842e909efd24fb927","modified":1619160730340},{"_id":"public/atom.xml","hash":"c304cc8d2d423d053ad5bb0237ad29d4b4c59839","modified":1619528155442},{"_id":"public/search.xml","hash":"14e232e38fb8ebe5abae626baef4aeb3f34a4649","modified":1619528155442},{"_id":"public/sitemap.xml","hash":"cff74ac6c5b1d77e130d7d43f96c0f78190fcffa","modified":1619528155442},{"_id":"public/categories/index.html","hash":"ca7ccdf553221100e98f5ba2af8d4d72488b215a","modified":1619528155442},{"_id":"public/2021/04/27/算法题6/index.html","hash":"28d90463eba0f5ed549ea9acfbb42adc2d9b056f","modified":1619528155442},{"_id":"public/tags/index.html","hash":"ed2838b12f802266634ec8dec7c9d2da4fcc9d3d","modified":1619528155442},{"_id":"public/2021/04/25/算法题5/index.html","hash":"9085daaf6f0d142ecd41b0559b1ef3bb49e9a85e","modified":1619528155442},{"_id":"public/2021/04/25/JavaScript中几个优雅的运算符使用技巧/index.html","hash":"b6c3e34a568163ebf5f22270e3757f9f7b71a146","modified":1619528155442},{"_id":"public/2021/04/23/算法题4/index.html","hash":"2065f5774d5b30b191cc1c8549b20be2489f46d5","modified":1619528155442},{"_id":"public/2021/04/22/算法题3/index.html","hash":"4058fe2625e6fa349ed46a15afc524f44daed98b","modified":1619528155442},{"_id":"public/2021/04/21/算法题2/index.html","hash":"f5fa476258aa9cdfbde9ca4a7dd7509cae1425de","modified":1619528155442},{"_id":"public/2021/04/20/算法题1/index.html","hash":"1cd7b9acc2c95984c7d4484c6d5ed03eca0b8e55","modified":1619528155442},{"_id":"public/2021/04/14/机器学习/index.html","hash":"bf9f552d86853e2f22bde7e902af1fc2c4926f4a","modified":1619528155442},{"_id":"public/2021/03/08/Markdown语法/index.html","hash":"faefe3b75cead52e80538d73ca243c920491a1c6","modified":1619528155442},{"_id":"public/2021/03/08/webpack打包后的代码是怎么样的/index.html","hash":"42ff0e65af0dfd8bf1fb9e245339e1048097f723","modified":1619528155442},{"_id":"public/archives/index.html","hash":"b271a616135443a0ccfe8272fa89f54a8a06a345","modified":1619528155442},{"_id":"public/archives/2021/index.html","hash":"9701644d782514e47424b092ea665d4eb8f68786","modified":1619528155442},{"_id":"public/archives/2021/03/index.html","hash":"d6a26c0f21f58716a0bd9d87fb9a317f89c4087b","modified":1619528155442},{"_id":"public/archives/2021/04/index.html","hash":"1e5463c9d0cfaa588bb084d38b08141454c714fa","modified":1619528155442},{"_id":"public/categories/Markdown/index.html","hash":"779e5063df4c272f26c5589e642fffad9567186c","modified":1619528155442},{"_id":"public/categories/每日一题/index.html","hash":"e49d61c1846013139dcbee88502fd96fd7cb04ea","modified":1619528155442},{"_id":"public/index.html","hash":"ced5bc5c7782a0a953d456ec0af05d8ac1091512","modified":1619528155442},{"_id":"public/tags/Markdown/index.html","hash":"64582b7006e6ce8392655e10a3daf84ac5c88a6f","modified":1619528155442},{"_id":"public/tags/JS/index.html","hash":"03274ee5bdb8154ad37df4e7078420d03e56efb2","modified":1619528155442},{"_id":"public/tags/webpack/index.html","hash":"cd47731bde500b761e785d7de39c7d2477566b7e","modified":1619528155442},{"_id":"public/tags/算法/index.html","hash":"28ea9a597092ce4fc5fefeeb04928b02989bbcf0","modified":1619528155442},{"_id":"public/tags/机器学习/index.html","hash":"3e59a4035fed0660857884051fb61486fc4e789b","modified":1619528155442},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1619528155442},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1619528155442},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1619528155442},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1619528155442},{"_id":"public/img/bg.jpeg","hash":"b3eb44c8a859a60adf6902f6c30ab7870c1b1e43","modified":1619528155442},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1619528155442},{"_id":"public/img/avatar.jpeg","hash":"9211fe14e648515a8f7d5c7842e909efd24fb927","modified":1619528155442},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619528155442},{"_id":"public/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1619528155442},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1619528155442},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1619528155442},{"_id":"public/css/index.css","hash":"54d7ae47406d6081c8b797e57c4c5af0cb495667","modified":1619528155442},{"_id":"public/js/main.js","hash":"8cf2fb897890fa5fbbffbe936d6fa80b383584d9","modified":1619528155442},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1619528155442}],"Category":[{"name":"Markdown","_id":"cko018yvh0004sgcmh3pd6jcg"},{"name":"每日一题","_id":"cko018yvm000asgcmd5o1eci4"}],"Data":[],"Page":[{"title":"分类","date":"2021-02-25T08:44:32.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-02-25 16:44:32\ntype: categories\ncomments: false\n---\n","updated":"2021-04-23T06:45:08.622Z","path":"categories/index.html","layout":"page","_id":"cko018yv90000sgcm9anq3d4s","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"标签","date":"2021-02-25T08:44:32.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-02-25 16:44:32\ntype: tags\ncomments: false\n---\n","updated":"2021-04-23T06:45:08.622Z","path":"tags/index.html","layout":"page","_id":"cko018yvf0002sgcm4ioo5lfb","content":"","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""}],"Post":[{"title":"Markdown语法","date":"2021-03-08T08:32:17.000Z","_content":"## 基本语法\n\n| 元素 | Markdown语法 |\n| ---- | ----------- |\n| 标题 | # h1 <br> ## h2 <br> ### h3 |\n| 粗体 | `**粗体**` |\n| 斜体 | `*斜体*` |\n| 引用块 | `>引用块` |\n| 有序列表 | `1. 列表1 2.列表2 3. 列表3` |\n| 无序列表 | `- 列表1 - 列表2 - 列表3` |\n| 代码 | ``代码`` |\n| 分割线 | `---` |\n| 链接 | `[title](https://www.example.com` |\n| 图片 | `![alt text](image.jpg)` |\n\n## 扩展语法\n\n| 元素 | Markdown语法 |\n| ---- | ----------- |\n| 表格 |  |\n| 代码块 | ` ```代码块``` ` |\n| 脚注 | `Here's a sentence with a footnote. [^1][^1]: This is the footnote.` |\n| 标题编号 | `### My Great Heading {#custom-id}` |\n| 定义列表 | `term: definition`  |\n| 删除线 | `~~删除线~~`  |\n| 任务列表 | `- [x] Write the press release - [ ] Update the website - [ ] Contact the media` |\n","source":"_posts/Markdown语法.md","raw":"---\ntitle: Markdown语法\ndate: 2021-03-08 16:32:17\ntags: Markdown\ncategories: Markdown\n---\n## 基本语法\n\n| 元素 | Markdown语法 |\n| ---- | ----------- |\n| 标题 | # h1 <br> ## h2 <br> ### h3 |\n| 粗体 | `**粗体**` |\n| 斜体 | `*斜体*` |\n| 引用块 | `>引用块` |\n| 有序列表 | `1. 列表1 2.列表2 3. 列表3` |\n| 无序列表 | `- 列表1 - 列表2 - 列表3` |\n| 代码 | ``代码`` |\n| 分割线 | `---` |\n| 链接 | `[title](https://www.example.com` |\n| 图片 | `![alt text](image.jpg)` |\n\n## 扩展语法\n\n| 元素 | Markdown语法 |\n| ---- | ----------- |\n| 表格 |  |\n| 代码块 | ` ```代码块``` ` |\n| 脚注 | `Here's a sentence with a footnote. [^1][^1]: This is the footnote.` |\n| 标题编号 | `### My Great Heading {#custom-id}` |\n| 定义列表 | `term: definition`  |\n| 删除线 | `~~删除线~~`  |\n| 任务列表 | `- [x] Write the press release - [ ] Update the website - [ ] Contact the media` |\n","slug":"Markdown语法","published":1,"updated":"2021-04-23T06:45:08.621Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvc0001sgcmdql2ft5s","content":"<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><table>\n<thead>\n<tr>\n<th>元素</th>\n<th>Markdown语法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标题</td>\n<td># h1 <br> ## h2 <br> ### h3</td>\n</tr>\n<tr>\n<td>粗体</td>\n<td><code>**粗体**</code></td>\n</tr>\n<tr>\n<td>斜体</td>\n<td><code>*斜体*</code></td>\n</tr>\n<tr>\n<td>引用块</td>\n<td><code>&gt;引用块</code></td>\n</tr>\n<tr>\n<td>有序列表</td>\n<td><code>1. 列表1 2.列表2 3. 列表3</code></td>\n</tr>\n<tr>\n<td>无序列表</td>\n<td><code>- 列表1 - 列表2 - 列表3</code></td>\n</tr>\n<tr>\n<td>代码</td>\n<td><code>代码</code></td>\n</tr>\n<tr>\n<td>分割线</td>\n<td><code>---</code></td>\n</tr>\n<tr>\n<td>链接</td>\n<td><code>[title](https://www.example.com</code></td>\n</tr>\n<tr>\n<td>图片</td>\n<td><code>![alt text](image.jpg)</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"扩展语法\"><a href=\"#扩展语法\" class=\"headerlink\" title=\"扩展语法\"></a>扩展语法</h2><table>\n<thead>\n<tr>\n<th>元素</th>\n<th>Markdown语法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>表格</td>\n<td></td>\n</tr>\n<tr>\n<td>代码块</td>\n<td><code>```代码块```</code></td>\n</tr>\n<tr>\n<td>脚注</td>\n<td><code>Here&#39;s a sentence with a footnote. [^1][^1]: This is the footnote.</code></td>\n</tr>\n<tr>\n<td>标题编号</td>\n<td><code>### My Great Heading &#123;#custom-id&#125;</code></td>\n</tr>\n<tr>\n<td>定义列表</td>\n<td><code>term: definition</code></td>\n</tr>\n<tr>\n<td>删除线</td>\n<td><code>~~删除线~~</code></td>\n</tr>\n<tr>\n<td>任务列表</td>\n<td><code>- [x] Write the press release - [ ] Update the website - [ ] Contact the media</code></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><table>\n<thead>\n<tr>\n<th>元素</th>\n<th>Markdown语法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标题</td>\n<td># h1 <br> ## h2 <br> ### h3</td>\n</tr>\n<tr>\n<td>粗体</td>\n<td><code>**粗体**</code></td>\n</tr>\n<tr>\n<td>斜体</td>\n<td><code>*斜体*</code></td>\n</tr>\n<tr>\n<td>引用块</td>\n<td><code>&gt;引用块</code></td>\n</tr>\n<tr>\n<td>有序列表</td>\n<td><code>1. 列表1 2.列表2 3. 列表3</code></td>\n</tr>\n<tr>\n<td>无序列表</td>\n<td><code>- 列表1 - 列表2 - 列表3</code></td>\n</tr>\n<tr>\n<td>代码</td>\n<td><code>代码</code></td>\n</tr>\n<tr>\n<td>分割线</td>\n<td><code>---</code></td>\n</tr>\n<tr>\n<td>链接</td>\n<td><code>[title](https://www.example.com</code></td>\n</tr>\n<tr>\n<td>图片</td>\n<td><code>![alt text](image.jpg)</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"扩展语法\"><a href=\"#扩展语法\" class=\"headerlink\" title=\"扩展语法\"></a>扩展语法</h2><table>\n<thead>\n<tr>\n<th>元素</th>\n<th>Markdown语法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>表格</td>\n<td></td>\n</tr>\n<tr>\n<td>代码块</td>\n<td><code>```代码块```</code></td>\n</tr>\n<tr>\n<td>脚注</td>\n<td><code>Here&#39;s a sentence with a footnote. [^1][^1]: This is the footnote.</code></td>\n</tr>\n<tr>\n<td>标题编号</td>\n<td><code>### My Great Heading &#123;#custom-id&#125;</code></td>\n</tr>\n<tr>\n<td>定义列表</td>\n<td><code>term: definition</code></td>\n</tr>\n<tr>\n<td>删除线</td>\n<td><code>~~删除线~~</code></td>\n</tr>\n<tr>\n<td>任务列表</td>\n<td><code>- [x] Write the press release - [ ] Update the website - [ ] Contact the media</code></td>\n</tr>\n</tbody></table>\n"},{"title":"JavaScript中几个优雅的运算符使用技巧","date":"2021-04-25T03:18:11.000Z","_content":"\n## 可选链接运算符【？.】\n\n```\nlet data;\nconsole.log(data?.children?.[0]?.title) // undefined\n\ndata  = {children: [{title:'codercao'}]}\nconsole.log(data?.children?.[0]?.title) // codercao\n```\n### 对于方法的调用你可以这样写\n\n```\nobject.runsOnlyIfMethodExists?.()\n```\n```\nlet parent = {\n    name: \"parent\",\n    friends: [\"p1\", \"p2\", \"p3\"],\n    getName: function() {\n      console.log(this.name)\n    }\n  };\n  \n  parent.getName?.()   // parent\n  parent.getTitle?.()  //不会执行\n  \n```\n### 与无效合并一起使用\n```\nlet title = data?.children?.[0]?.title ?? 'codercao';\nconsole.log(title); // codercao\n```\n## 逻辑空分配（?? =）\n\n逻辑空值运算符仅在空值（空值或未定义）时才将值分配给expr1，表达方式\n```\nexpr1 ??= expr2\n\n```\n\n## 逻辑或分配（|| =）\n\n此逻辑赋值运算符仅在左侧表达式为 falsy值时才赋值。Falsy与null有所不同，因为falsy可以是任何一种值：false，0，“”，null，undefined和NaN等\n\n在我们想要保留现有值（如果不存在）的情况下，这很有用，否则我们想为其分配默认值。例如，如果搜索请求中没有数据，我们希望将元素的内部HTML设置为默认值。否则，我们要显示现有列表。这样，我们避免了不必要的更新和任何副作用，例如解析，重新渲染，失去焦点等。我们可以简单地使用此运算符来使用JavaScript更新HTML：\n\n```\ndocument.getElementById('search').innerHTML ||= '<i>No posts found matching this search.</i>'\n```\n\n## 逻辑与分配（&& =）\n\n此逻辑赋值运算符仅在左侧为真时才赋值\n\n```\nx &&= y\n```\n等同于\n```\nx && (x = y)\n```","source":"_posts/JavaScript中几个优雅的运算符使用技巧.md","raw":"---\ntitle: JavaScript中几个优雅的运算符使用技巧\ndate: 2021-04-25 11:18:11\ntags: JS\n---\n\n## 可选链接运算符【？.】\n\n```\nlet data;\nconsole.log(data?.children?.[0]?.title) // undefined\n\ndata  = {children: [{title:'codercao'}]}\nconsole.log(data?.children?.[0]?.title) // codercao\n```\n### 对于方法的调用你可以这样写\n\n```\nobject.runsOnlyIfMethodExists?.()\n```\n```\nlet parent = {\n    name: \"parent\",\n    friends: [\"p1\", \"p2\", \"p3\"],\n    getName: function() {\n      console.log(this.name)\n    }\n  };\n  \n  parent.getName?.()   // parent\n  parent.getTitle?.()  //不会执行\n  \n```\n### 与无效合并一起使用\n```\nlet title = data?.children?.[0]?.title ?? 'codercao';\nconsole.log(title); // codercao\n```\n## 逻辑空分配（?? =）\n\n逻辑空值运算符仅在空值（空值或未定义）时才将值分配给expr1，表达方式\n```\nexpr1 ??= expr2\n\n```\n\n## 逻辑或分配（|| =）\n\n此逻辑赋值运算符仅在左侧表达式为 falsy值时才赋值。Falsy与null有所不同，因为falsy可以是任何一种值：false，0，“”，null，undefined和NaN等\n\n在我们想要保留现有值（如果不存在）的情况下，这很有用，否则我们想为其分配默认值。例如，如果搜索请求中没有数据，我们希望将元素的内部HTML设置为默认值。否则，我们要显示现有列表。这样，我们避免了不必要的更新和任何副作用，例如解析，重新渲染，失去焦点等。我们可以简单地使用此运算符来使用JavaScript更新HTML：\n\n```\ndocument.getElementById('search').innerHTML ||= '<i>No posts found matching this search.</i>'\n```\n\n## 逻辑与分配（&& =）\n\n此逻辑赋值运算符仅在左侧为真时才赋值\n\n```\nx &&= y\n```\n等同于\n```\nx && (x = y)\n```","slug":"JavaScript中几个优雅的运算符使用技巧","published":1,"updated":"2021-04-25T05:53:38.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvf0003sgcm7wuv3anc","content":"<h2 id=\"可选链接运算符【？-】\"><a href=\"#可选链接运算符【？-】\" class=\"headerlink\" title=\"可选链接运算符【？.】\"></a>可选链接运算符【？.】</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let data;</span><br><span class=\"line\">console.log(data?.children?.[0]?.title) &#x2F;&#x2F; undefined</span><br><span class=\"line\"></span><br><span class=\"line\">data  &#x3D; &#123;children: [&#123;title:&#39;codercao&#39;&#125;]&#125;</span><br><span class=\"line\">console.log(data?.children?.[0]?.title) &#x2F;&#x2F; codercao</span><br></pre></td></tr></table></figure>\n<h3 id=\"对于方法的调用你可以这样写\"><a href=\"#对于方法的调用你可以这样写\" class=\"headerlink\" title=\"对于方法的调用你可以这样写\"></a>对于方法的调用你可以这样写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object.runsOnlyIfMethodExists?.()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let parent &#x3D; &#123;</span><br><span class=\"line\">    name: &quot;parent&quot;,</span><br><span class=\"line\">    friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">      console.log(this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  parent.getName?.()   &#x2F;&#x2F; parent</span><br><span class=\"line\">  parent.getTitle?.()  &#x2F;&#x2F;不会执行</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n<h3 id=\"与无效合并一起使用\"><a href=\"#与无效合并一起使用\" class=\"headerlink\" title=\"与无效合并一起使用\"></a>与无效合并一起使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let title &#x3D; data?.children?.[0]?.title ?? &#39;codercao&#39;;</span><br><span class=\"line\">console.log(title); &#x2F;&#x2F; codercao</span><br></pre></td></tr></table></figure>\n<h2 id=\"逻辑空分配（-）\"><a href=\"#逻辑空分配（-）\" class=\"headerlink\" title=\"逻辑空分配（?? =）\"></a>逻辑空分配（?? =）</h2><p>逻辑空值运算符仅在空值（空值或未定义）时才将值分配给expr1，表达方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expr1 ??&#x3D; expr2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逻辑或分配（-）\"><a href=\"#逻辑或分配（-）\" class=\"headerlink\" title=\"逻辑或分配（|| =）\"></a>逻辑或分配（|| =）</h2><p>此逻辑赋值运算符仅在左侧表达式为 falsy值时才赋值。Falsy与null有所不同，因为falsy可以是任何一种值：false，0，“”，null，undefined和NaN等</p>\n<p>在我们想要保留现有值（如果不存在）的情况下，这很有用，否则我们想为其分配默认值。例如，如果搜索请求中没有数据，我们希望将元素的内部HTML设置为默认值。否则，我们要显示现有列表。这样，我们避免了不必要的更新和任何副作用，例如解析，重新渲染，失去焦点等。我们可以简单地使用此运算符来使用JavaScript更新HTML：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&#39;search&#39;).innerHTML ||&#x3D; &#39;&lt;i&gt;No posts found matching this search.&lt;&#x2F;i&gt;&#39;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逻辑与分配（-amp-amp-）\"><a href=\"#逻辑与分配（-amp-amp-）\" class=\"headerlink\" title=\"逻辑与分配（&amp;&amp; =）\"></a>逻辑与分配（&amp;&amp; =）</h2><p>此逻辑赋值运算符仅在左侧为真时才赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x &amp;&amp;&#x3D; y</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x &amp;&amp; (x &#x3D; y)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"可选链接运算符【？-】\"><a href=\"#可选链接运算符【？-】\" class=\"headerlink\" title=\"可选链接运算符【？.】\"></a>可选链接运算符【？.】</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let data;</span><br><span class=\"line\">console.log(data?.children?.[0]?.title) &#x2F;&#x2F; undefined</span><br><span class=\"line\"></span><br><span class=\"line\">data  &#x3D; &#123;children: [&#123;title:&#39;codercao&#39;&#125;]&#125;</span><br><span class=\"line\">console.log(data?.children?.[0]?.title) &#x2F;&#x2F; codercao</span><br></pre></td></tr></table></figure>\n<h3 id=\"对于方法的调用你可以这样写\"><a href=\"#对于方法的调用你可以这样写\" class=\"headerlink\" title=\"对于方法的调用你可以这样写\"></a>对于方法的调用你可以这样写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">object.runsOnlyIfMethodExists?.()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let parent &#x3D; &#123;</span><br><span class=\"line\">    name: &quot;parent&quot;,</span><br><span class=\"line\">    friends: [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;],</span><br><span class=\"line\">    getName: function() &#123;</span><br><span class=\"line\">      console.log(this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  parent.getName?.()   &#x2F;&#x2F; parent</span><br><span class=\"line\">  parent.getTitle?.()  &#x2F;&#x2F;不会执行</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure>\n<h3 id=\"与无效合并一起使用\"><a href=\"#与无效合并一起使用\" class=\"headerlink\" title=\"与无效合并一起使用\"></a>与无效合并一起使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let title &#x3D; data?.children?.[0]?.title ?? &#39;codercao&#39;;</span><br><span class=\"line\">console.log(title); &#x2F;&#x2F; codercao</span><br></pre></td></tr></table></figure>\n<h2 id=\"逻辑空分配（-）\"><a href=\"#逻辑空分配（-）\" class=\"headerlink\" title=\"逻辑空分配（?? =）\"></a>逻辑空分配（?? =）</h2><p>逻辑空值运算符仅在空值（空值或未定义）时才将值分配给expr1，表达方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">expr1 ??&#x3D; expr2</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逻辑或分配（-）\"><a href=\"#逻辑或分配（-）\" class=\"headerlink\" title=\"逻辑或分配（|| =）\"></a>逻辑或分配（|| =）</h2><p>此逻辑赋值运算符仅在左侧表达式为 falsy值时才赋值。Falsy与null有所不同，因为falsy可以是任何一种值：false，0，“”，null，undefined和NaN等</p>\n<p>在我们想要保留现有值（如果不存在）的情况下，这很有用，否则我们想为其分配默认值。例如，如果搜索请求中没有数据，我们希望将元素的内部HTML设置为默认值。否则，我们要显示现有列表。这样，我们避免了不必要的更新和任何副作用，例如解析，重新渲染，失去焦点等。我们可以简单地使用此运算符来使用JavaScript更新HTML：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&#39;search&#39;).innerHTML ||&#x3D; &#39;&lt;i&gt;No posts found matching this search.&lt;&#x2F;i&gt;&#39;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逻辑与分配（-amp-amp-）\"><a href=\"#逻辑与分配（-amp-amp-）\" class=\"headerlink\" title=\"逻辑与分配（&amp;&amp; =）\"></a>逻辑与分配（&amp;&amp; =）</h2><p>此逻辑赋值运算符仅在左侧为真时才赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x &amp;&amp;&#x3D; y</span><br></pre></td></tr></table></figure>\n<p>等同于</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x &amp;&amp; (x &#x3D; y)</span><br></pre></td></tr></table></figure>"},{"title":"webpack打包后的代码是怎么样的","date":"2021-03-08T07:55:59.000Z","_content":"## 准备工作\n\n``` bash\nmkdir webpack\ncd webpack\nnpm init -y\nyarn add webpack webpack-cli -D\n```\n根目录中新建文件webpack.config.js\n\n```\nconst path = require('path')\n\nmodule.exports = {\n    mode: 'development', // 环境\n    entry: './src/index.js',// 入口\n    output: {//出口\n        filename: 'bundle.js',\n        path: path.resolve(__dirname, './dist')\n    },\n    devtool: 'cheap-source-map'// 为了更加方便查看输出\n}\n```\n在package.json中加入启动webpack的命令\n```\n\"scripts\": {\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n  \"build\": \"webpack\"\n}\n```\n新建一个 src文件夹，新增 index.js 文件\n执行yarn build\n\n## 分析主流程\n\n### IFFE\n\n看输出的文件，整体上是一个IIFE(立即执行函数)\n```\n(function(modules) { // webpackBootstrap\n\t// The module cache\n\tvar installedModules = {};\n\tfunction __webpack_require__(moduleId) {\n    // ...省略细节\n\t}\n\t// 入口文件\n\treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n})\n({\n\n \"./src/index.js\": (function(module, __webpack_exports__, __webpack_require__) {}),\n  \"./src/sayHello.js\": (function(module, __webpack_exports__, __webpack_require__) {})\n});\n```\n函数的入参modules是一个对象，对象的key就是每个js模块的相对路径，value就是模块函数。\n\nIIFE会先require入口模块，然后入口模块会在执行时require其他模块，从而不断加载所需要的模块，形成依赖树\n\n### 重要的实现机制——__webpack_require__\n\n```\n  // 缓存模块使用\n  var installedModules = {};\n  // The require function\n  // 模拟模块的加载，webpack 实现的 require\n  function __webpack_require__(moduleId) {\n    // Check if module is in cache\n    // 检查模块是否在缓存中，有则直接从缓存中获取\n    if(installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    // 没有则创建并放入缓存中，其中 key 值就是模块 Id,也就是上面所说的文件路径\n    var module = installedModules[moduleId] = {\n      i: moduleId, // Module ID\n      l: false, // 是否已经执行\n      exports: {}\n    };\n\n    // Execute the module function\n    // 执行模块函数，挂载到 module.exports 上。this 指向 module.exports\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n    // Flag the module as loaded\n    // 标记这个 module 已经被加载\n    module.l = true;\n\n    // Return the exports of the module\n    // module.exports通过在执行module的时候，作为参数存进去，然后会保存module中暴露给外界的接口，如函数、变量等\n    return module.exports;\n  }\n```\n第一步，webpack 这里做了一层优化，通过对象 installedModules 进行缓存，检查模块是否在缓存中，有则直接从缓存中获取，没有则创建并放入缓存中，其中 key 值就是模块 Id，也就是上面所说的文件路径\n\n第二步，然后执行模块函数，将 module, module.exports, __webpack_require__ 作为参数传递，并把模块的函数调用对象指向 module.exports，保证模块中的 this 指向永远指向当前的模块。\n\n第三步，最后返回加载的模块，调用方直接调用即可。\n\n所以这个__webpack_require__就是来加载一个模块，并在最后返回模块 module.exports 变量\n\n### webpack 是如何支持 ESM 的\n\n#### __webpack_require__.r 函数\n\n```\n__webpack_require__.r = (exports) => {\n \tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n        Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t}\n \tObject.defineProperty(exports, '__esModule', { value: true });\n };\n```\n就是为__webpack_exports__ 添加__esModule属性 值为true\n\n#### __webpack_require__.n 函数\n\n```\n__webpack_require__.n = (module) => {\n \tvar getter = module && module.__esModule ?\n        () => (module['default']) :\n        () => (module);\n \t__webpack_require__.d(getter, { a: getter });\n \treturn getter;\n };\n```\n__webpack_require__.n会判断modules是否为es模块，当__esModule为true时，标识module为es模块，默认返回module['default']，否则返回module\n\n#### __webpack_require__.d\n\n```\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};\n```\n__webpack_require__.d主要的工作就是将上面的 getter 函数绑定到 exports 中的属性 a 的 getter 上\n\n打包后的模块函数。可以看出导出的是__webpack_exports__[\"default\"]，实际上就是 __webpack_require__.n 做了一层包装来实现的，其实也可以看出，实际上 webpack 是可以支持 CommonJS 和 ES Module 一起混用的\n\n## 动态导入\n\n代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。\n\n常见的代码分割有以下几种方法：\n\n入口起点：使用 entry 配置手动地分离代码。\n防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。\n动态导入：通过模块的内联函数调用来分离代码。\n\n### __webpack_require__.e ——使用 JSONP 动态加载\n\n```\n// 已加载的chunk缓存\nvar installedChunks = {\n  \"main\": 0\n};\n// ...\n__webpack_require__.e = function requireEnsure(chunkId) {\n  // promises 队列，等待多个异步 chunk 都加载完成才执行回调\n  var promises = [];\n\n  // JSONP chunk loading for javascript\n  var installedChunkData = installedChunks[chunkId];\n  // 0 代表已经 installed\n  if(installedChunkData !== 0) { // 0 means \"already installed\".\n\n    // a Promise means \"currently loading\".\n    // 目标chunk正在加载，则将 promise push到 promises 数组\n    if(installedChunkData) {\n      promises.push(installedChunkData[2]);\n    } else {\n      // setup Promise in chunk cache\n      // 利用Promise去异步加载目标chunk\n      var promise = new Promise(function(resolve, reject) {\n        // 设置 installedChunks[chunkId]\n        installedChunkData = installedChunks[chunkId] = [resolve, reject];\n      });\n      // i设置chunk加载的三种状态并缓存在 installedChunks 中，防止chunk重复加载\n      // nstalledChunks[chunkId]  = [resolve, reject, promise]\n      promises.push(installedChunkData[2] = promise);\n      // start chunk loading\n      // 使用 JSONP\n      var head = document.getElementsByTagName('head')[0];\n      var script = document.createElement('script');\n\n      script.charset = 'utf-8';\n      script.timeout = 120;\n\n      if (__webpack_require__.nc) {\n        script.setAttribute(\"nonce\", __webpack_require__.nc);\n      }\n      // 获取目标chunk的地址，__webpack_require__.p 表示设置的publicPath，默认为空串\n      script.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n      // 请求超时的时候直接调用方法结束，时间为 120 s\n      var timeout = setTimeout(function(){\n        onScriptComplete({ type: 'timeout', target: script });\n      }, 120000);\n      script.onerror = script.onload = onScriptComplete;\n      // 设置加载完成或者错误的回调\n      function onScriptComplete(event) {\n        // avoid mem leaks in IE.\n        // 防止 IE 内存泄露\n        script.onerror = script.onload = null;\n        clearTimeout(timeout);\n        var chunk = installedChunks[chunkId];\n        // 如果为 0 则表示已加载，主要逻辑看 webpackJsonpCallback 函数\n        if(chunk !== 0) {\n          if(chunk) {\n            var errorType = event && (event.type === 'load' ? 'missing' : event.type);\n            var realSrc = event && event.target && event.target.src;\n            var error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\n            error.type = errorType;\n            error.request = realSrc;\n            chunk[1](error);\n          }\n          installedChunks[chunkId] = undefined;\n        }\n      };\n      head.appendChild(script);\n    }\n  }\n  return Promise.all(promises);\n};\n```\n可以看出将 import() 转换成模拟 JSONP 去加载动态加载的 chunk 文件\n\n\n设置 chunk 加载的三种状态并缓存在installedChunks中，防止chunk重复加载。这些状态的改变会在 webpackJsonpCallback 中提到\n```\n// 设置 installedChunks[chunkId]\ninstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n```\ninstalledChunks[chunkId]为0，代表该 chunk 已经加载完毕\ninstalledChunks[chunkId]为undefined，代表该 chunk 加载失败、加载超时、从未加载过\ninstalledChunks[chunkId]为Promise对象，代表该 chunk 正在加载\n\n看完__webpack_require__.e，我们知道的是，我们通过 JSONP 去动态引入 chunk 文件，并根据引入的结果状态进行处理，那么我们怎么知道引入之后的状态呢？我们来看异步加载的 chunk 是怎样的\n\n### 异步 Chunk\n\n```\n// window[\"webpackJsonp\"] 实际上是一个数组，向中添加一个元素。这个元素也是一个数组，其中数组的第一个元素是chunkId，第二个对象，跟传入到 IIFE 中的参数一样\n(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[0],{\n\n  /***/ \"./src/Another.js\":\n  /***/ (function(module, __webpack_exports__, __webpack_require__) {\n  \n  \"use strict\";\n  __webpack_require__.r(__webpack_exports__);\n  /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Another\", function() { return Another; });\n  function Another() {\n    return 'Hi, I am Another Module';\n  }\n  /***/ })\n  \n  }]);\n  //# sourceMappingURL=0.bundle.js.map\n```\n主要做的事情就是往一个数组 window['webpackJsonp'] 中塞入一个元素，这个元素也是一个数组，其中数组的第一个元素是 chunkId，第二个对象，跟主 chunk 中 IIFE 传入的参数类似。关键是这个 window['webpackJsonp'] 在哪里会用到呢？我们回到主 chunk 中。在 return __webpack_require__(__webpack_require__.s = \"./src/index.js\"); 进入入口之前还有一段\n```\nvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n// 保存原始的 Array.prototype.push 方法\nvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n// 将 push 方法的实现修改为 webpackJsonpCallback\n// 这样我们在异步 chunk 中执行的 window['webpackJsonp'].push 其实是 webpackJsonpCallback 函数。\njsonpArray.push = webpackJsonpCallback;\njsonpArray = jsonpArray.slice();\n// 对已在数组中的元素依次执行webpackJsonpCallback方法\nfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\nvar parentJsonpFunction = oldJsonpFunction;\n```\njsonpArray 就是 window[\"webpackJsonp\"] ，重点看下面这一句代码，当执行 push 方法的时候，就会执行 webpackJsonpCallback，相当于做了一层劫持，也就是执行完 push 操作的时候就会调用这个函数\n```\njsonpArray.push = webpackJsonpCallback;\n```\nwebpackJsonpCallback ——加载完动态 chunk 之后的回调\n我们再来看看  webpackJsonpCallback 函数，这里的入参就是动态加载的 chunk 的 window['webpackJsonp'] push 进去的参数。\n```\nvar installedChunks = {\n  \"main\": 0\n};\t\n\nfunction webpackJsonpCallback(data) {\n  // window[\"webpackJsonp\"] 中的第一个参数——即[0]\n  var chunkIds = data[0];\n  // 对应的模块详细信息，详见打包出来的 chunk 模块中的 push 进 window[\"webpackJsonp\"] 中的第二个参数\n  var moreModules = data[1];\n\n  // add \"moreModules\" to the modules object,\n  // then flag all \"chunkIds\" as loaded and fire callback\n  var moduleId, chunkId, i = 0, resolves = [];\n  for(;i < chunkIds.length; i++) {\n    chunkId = chunkIds[i];\n    // 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]\n    // 这个可以看 __webpack_require__.e 中设置的状态\n    // 表示正在执行的chunk，加入到 resolves 数组中\n    if(installedChunks[chunkId]) {\n      resolves.push(installedChunks[chunkId][0]);\n    }\n    // 标记成已经执行完\n    installedChunks[chunkId] = 0;\n  }\n  // 挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中\n  for(moduleId in moreModules) {\n    if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n      modules[moduleId] = moreModules[moduleId];\n    }\n  }\n  // parentJsonpFunction: 原始的数组 push 方法，将 data 加入 window[\"webpackJsonp\"] 数组。\n  if(parentJsonpFunction) parentJsonpFunction(data);\n  // 等到 while 循环结束后，__webpack_require__.e 的返回值 Promise 得到 resolve\n  // 执行 resolove\n  while(resolves.length) {\n    resolves.shift()();\n  }\n};\n```\n当我们 JSONP 去加载异步 chunk 完成之后，就会去执行 window[\"webpackJsonp\"] || []).push，也就是 webpackJsonpCallback。主要有以下几步\n\n遍历要加载的 chunkIds，找到未执行完的 chunk，并加入到 resolves 中\n```\nfor(;i < chunkIds.length; i++) {\n  chunkId = chunkIds[i];\n  // 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]\n  // 这个可以看 __webpack_require__.e 中设置的状态\n  // 表示正在执行的chunk，加入到 resolves 数组中\n  if(installedChunks[chunkId]) {\n    resolves.push(installedChunks[chunkId][0]);\n  }\n  // 标记成已经执行完\n  installedChunks[chunkId] = 0;\n}\n```\n这里未执行的是非 0 状态，执行完就设置为0\n\ninstalledChunks[chunkId][0] 实际上就是 Promise 构造函数中的 resolve\n\n```\n// __webpack_require__.e \nvar promise = new Promise(function(resolve, reject) {\n\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n});\n```\n\n挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中\n\n\n原始的数组 push 方法，将 data 加入 window[\"webpackJsonp\"] 数组\n\n\n执行各个 resolves 方法，告诉 __webpack_require__.e 中回调函数的状态\n\n只有当这个方法执行完成的时候，我们才知道 JSONP 成功与否，也就是script.onload/onerror 会在 webpackJsonpCallback 之后执行。所以 onload/onerror 其实是用来检查 webpackJsonpCallback 的完成度：有没有将 installedChunks 中对应的 chunk 值设为 0\n\n大致的流程如下图所示\n\n[image.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/234b9478b2764bddbeee6c539d85c4ff~tplv-k3u1fbpfcp-zoom-1.image)","source":"_posts/webpack打包后的代码是怎么样的.md","raw":"---\ntitle: webpack打包后的代码是怎么样的\ndate: 2021-03-08 15:55:59\ntags: webpack\n---\n## 准备工作\n\n``` bash\nmkdir webpack\ncd webpack\nnpm init -y\nyarn add webpack webpack-cli -D\n```\n根目录中新建文件webpack.config.js\n\n```\nconst path = require('path')\n\nmodule.exports = {\n    mode: 'development', // 环境\n    entry: './src/index.js',// 入口\n    output: {//出口\n        filename: 'bundle.js',\n        path: path.resolve(__dirname, './dist')\n    },\n    devtool: 'cheap-source-map'// 为了更加方便查看输出\n}\n```\n在package.json中加入启动webpack的命令\n```\n\"scripts\": {\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n  \"build\": \"webpack\"\n}\n```\n新建一个 src文件夹，新增 index.js 文件\n执行yarn build\n\n## 分析主流程\n\n### IFFE\n\n看输出的文件，整体上是一个IIFE(立即执行函数)\n```\n(function(modules) { // webpackBootstrap\n\t// The module cache\n\tvar installedModules = {};\n\tfunction __webpack_require__(moduleId) {\n    // ...省略细节\n\t}\n\t// 入口文件\n\treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n})\n({\n\n \"./src/index.js\": (function(module, __webpack_exports__, __webpack_require__) {}),\n  \"./src/sayHello.js\": (function(module, __webpack_exports__, __webpack_require__) {})\n});\n```\n函数的入参modules是一个对象，对象的key就是每个js模块的相对路径，value就是模块函数。\n\nIIFE会先require入口模块，然后入口模块会在执行时require其他模块，从而不断加载所需要的模块，形成依赖树\n\n### 重要的实现机制——__webpack_require__\n\n```\n  // 缓存模块使用\n  var installedModules = {};\n  // The require function\n  // 模拟模块的加载，webpack 实现的 require\n  function __webpack_require__(moduleId) {\n    // Check if module is in cache\n    // 检查模块是否在缓存中，有则直接从缓存中获取\n    if(installedModules[moduleId]) {\n      return installedModules[moduleId].exports;\n    }\n    // Create a new module (and put it into the cache)\n    // 没有则创建并放入缓存中，其中 key 值就是模块 Id,也就是上面所说的文件路径\n    var module = installedModules[moduleId] = {\n      i: moduleId, // Module ID\n      l: false, // 是否已经执行\n      exports: {}\n    };\n\n    // Execute the module function\n    // 执行模块函数，挂载到 module.exports 上。this 指向 module.exports\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n    // Flag the module as loaded\n    // 标记这个 module 已经被加载\n    module.l = true;\n\n    // Return the exports of the module\n    // module.exports通过在执行module的时候，作为参数存进去，然后会保存module中暴露给外界的接口，如函数、变量等\n    return module.exports;\n  }\n```\n第一步，webpack 这里做了一层优化，通过对象 installedModules 进行缓存，检查模块是否在缓存中，有则直接从缓存中获取，没有则创建并放入缓存中，其中 key 值就是模块 Id，也就是上面所说的文件路径\n\n第二步，然后执行模块函数，将 module, module.exports, __webpack_require__ 作为参数传递，并把模块的函数调用对象指向 module.exports，保证模块中的 this 指向永远指向当前的模块。\n\n第三步，最后返回加载的模块，调用方直接调用即可。\n\n所以这个__webpack_require__就是来加载一个模块，并在最后返回模块 module.exports 变量\n\n### webpack 是如何支持 ESM 的\n\n#### __webpack_require__.r 函数\n\n```\n__webpack_require__.r = (exports) => {\n \tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n        Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t}\n \tObject.defineProperty(exports, '__esModule', { value: true });\n };\n```\n就是为__webpack_exports__ 添加__esModule属性 值为true\n\n#### __webpack_require__.n 函数\n\n```\n__webpack_require__.n = (module) => {\n \tvar getter = module && module.__esModule ?\n        () => (module['default']) :\n        () => (module);\n \t__webpack_require__.d(getter, { a: getter });\n \treturn getter;\n };\n```\n__webpack_require__.n会判断modules是否为es模块，当__esModule为true时，标识module为es模块，默认返回module['default']，否则返回module\n\n#### __webpack_require__.d\n\n```\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};\n```\n__webpack_require__.d主要的工作就是将上面的 getter 函数绑定到 exports 中的属性 a 的 getter 上\n\n打包后的模块函数。可以看出导出的是__webpack_exports__[\"default\"]，实际上就是 __webpack_require__.n 做了一层包装来实现的，其实也可以看出，实际上 webpack 是可以支持 CommonJS 和 ES Module 一起混用的\n\n## 动态导入\n\n代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。\n\n常见的代码分割有以下几种方法：\n\n入口起点：使用 entry 配置手动地分离代码。\n防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。\n动态导入：通过模块的内联函数调用来分离代码。\n\n### __webpack_require__.e ——使用 JSONP 动态加载\n\n```\n// 已加载的chunk缓存\nvar installedChunks = {\n  \"main\": 0\n};\n// ...\n__webpack_require__.e = function requireEnsure(chunkId) {\n  // promises 队列，等待多个异步 chunk 都加载完成才执行回调\n  var promises = [];\n\n  // JSONP chunk loading for javascript\n  var installedChunkData = installedChunks[chunkId];\n  // 0 代表已经 installed\n  if(installedChunkData !== 0) { // 0 means \"already installed\".\n\n    // a Promise means \"currently loading\".\n    // 目标chunk正在加载，则将 promise push到 promises 数组\n    if(installedChunkData) {\n      promises.push(installedChunkData[2]);\n    } else {\n      // setup Promise in chunk cache\n      // 利用Promise去异步加载目标chunk\n      var promise = new Promise(function(resolve, reject) {\n        // 设置 installedChunks[chunkId]\n        installedChunkData = installedChunks[chunkId] = [resolve, reject];\n      });\n      // i设置chunk加载的三种状态并缓存在 installedChunks 中，防止chunk重复加载\n      // nstalledChunks[chunkId]  = [resolve, reject, promise]\n      promises.push(installedChunkData[2] = promise);\n      // start chunk loading\n      // 使用 JSONP\n      var head = document.getElementsByTagName('head')[0];\n      var script = document.createElement('script');\n\n      script.charset = 'utf-8';\n      script.timeout = 120;\n\n      if (__webpack_require__.nc) {\n        script.setAttribute(\"nonce\", __webpack_require__.nc);\n      }\n      // 获取目标chunk的地址，__webpack_require__.p 表示设置的publicPath，默认为空串\n      script.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n      // 请求超时的时候直接调用方法结束，时间为 120 s\n      var timeout = setTimeout(function(){\n        onScriptComplete({ type: 'timeout', target: script });\n      }, 120000);\n      script.onerror = script.onload = onScriptComplete;\n      // 设置加载完成或者错误的回调\n      function onScriptComplete(event) {\n        // avoid mem leaks in IE.\n        // 防止 IE 内存泄露\n        script.onerror = script.onload = null;\n        clearTimeout(timeout);\n        var chunk = installedChunks[chunkId];\n        // 如果为 0 则表示已加载，主要逻辑看 webpackJsonpCallback 函数\n        if(chunk !== 0) {\n          if(chunk) {\n            var errorType = event && (event.type === 'load' ? 'missing' : event.type);\n            var realSrc = event && event.target && event.target.src;\n            var error = new Error('Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')');\n            error.type = errorType;\n            error.request = realSrc;\n            chunk[1](error);\n          }\n          installedChunks[chunkId] = undefined;\n        }\n      };\n      head.appendChild(script);\n    }\n  }\n  return Promise.all(promises);\n};\n```\n可以看出将 import() 转换成模拟 JSONP 去加载动态加载的 chunk 文件\n\n\n设置 chunk 加载的三种状态并缓存在installedChunks中，防止chunk重复加载。这些状态的改变会在 webpackJsonpCallback 中提到\n```\n// 设置 installedChunks[chunkId]\ninstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n```\ninstalledChunks[chunkId]为0，代表该 chunk 已经加载完毕\ninstalledChunks[chunkId]为undefined，代表该 chunk 加载失败、加载超时、从未加载过\ninstalledChunks[chunkId]为Promise对象，代表该 chunk 正在加载\n\n看完__webpack_require__.e，我们知道的是，我们通过 JSONP 去动态引入 chunk 文件，并根据引入的结果状态进行处理，那么我们怎么知道引入之后的状态呢？我们来看异步加载的 chunk 是怎样的\n\n### 异步 Chunk\n\n```\n// window[\"webpackJsonp\"] 实际上是一个数组，向中添加一个元素。这个元素也是一个数组，其中数组的第一个元素是chunkId，第二个对象，跟传入到 IIFE 中的参数一样\n(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[0],{\n\n  /***/ \"./src/Another.js\":\n  /***/ (function(module, __webpack_exports__, __webpack_require__) {\n  \n  \"use strict\";\n  __webpack_require__.r(__webpack_exports__);\n  /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Another\", function() { return Another; });\n  function Another() {\n    return 'Hi, I am Another Module';\n  }\n  /***/ })\n  \n  }]);\n  //# sourceMappingURL=0.bundle.js.map\n```\n主要做的事情就是往一个数组 window['webpackJsonp'] 中塞入一个元素，这个元素也是一个数组，其中数组的第一个元素是 chunkId，第二个对象，跟主 chunk 中 IIFE 传入的参数类似。关键是这个 window['webpackJsonp'] 在哪里会用到呢？我们回到主 chunk 中。在 return __webpack_require__(__webpack_require__.s = \"./src/index.js\"); 进入入口之前还有一段\n```\nvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n// 保存原始的 Array.prototype.push 方法\nvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n// 将 push 方法的实现修改为 webpackJsonpCallback\n// 这样我们在异步 chunk 中执行的 window['webpackJsonp'].push 其实是 webpackJsonpCallback 函数。\njsonpArray.push = webpackJsonpCallback;\njsonpArray = jsonpArray.slice();\n// 对已在数组中的元素依次执行webpackJsonpCallback方法\nfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\nvar parentJsonpFunction = oldJsonpFunction;\n```\njsonpArray 就是 window[\"webpackJsonp\"] ，重点看下面这一句代码，当执行 push 方法的时候，就会执行 webpackJsonpCallback，相当于做了一层劫持，也就是执行完 push 操作的时候就会调用这个函数\n```\njsonpArray.push = webpackJsonpCallback;\n```\nwebpackJsonpCallback ——加载完动态 chunk 之后的回调\n我们再来看看  webpackJsonpCallback 函数，这里的入参就是动态加载的 chunk 的 window['webpackJsonp'] push 进去的参数。\n```\nvar installedChunks = {\n  \"main\": 0\n};\t\n\nfunction webpackJsonpCallback(data) {\n  // window[\"webpackJsonp\"] 中的第一个参数——即[0]\n  var chunkIds = data[0];\n  // 对应的模块详细信息，详见打包出来的 chunk 模块中的 push 进 window[\"webpackJsonp\"] 中的第二个参数\n  var moreModules = data[1];\n\n  // add \"moreModules\" to the modules object,\n  // then flag all \"chunkIds\" as loaded and fire callback\n  var moduleId, chunkId, i = 0, resolves = [];\n  for(;i < chunkIds.length; i++) {\n    chunkId = chunkIds[i];\n    // 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]\n    // 这个可以看 __webpack_require__.e 中设置的状态\n    // 表示正在执行的chunk，加入到 resolves 数组中\n    if(installedChunks[chunkId]) {\n      resolves.push(installedChunks[chunkId][0]);\n    }\n    // 标记成已经执行完\n    installedChunks[chunkId] = 0;\n  }\n  // 挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中\n  for(moduleId in moreModules) {\n    if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n      modules[moduleId] = moreModules[moduleId];\n    }\n  }\n  // parentJsonpFunction: 原始的数组 push 方法，将 data 加入 window[\"webpackJsonp\"] 数组。\n  if(parentJsonpFunction) parentJsonpFunction(data);\n  // 等到 while 循环结束后，__webpack_require__.e 的返回值 Promise 得到 resolve\n  // 执行 resolove\n  while(resolves.length) {\n    resolves.shift()();\n  }\n};\n```\n当我们 JSONP 去加载异步 chunk 完成之后，就会去执行 window[\"webpackJsonp\"] || []).push，也就是 webpackJsonpCallback。主要有以下几步\n\n遍历要加载的 chunkIds，找到未执行完的 chunk，并加入到 resolves 中\n```\nfor(;i < chunkIds.length; i++) {\n  chunkId = chunkIds[i];\n  // 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]\n  // 这个可以看 __webpack_require__.e 中设置的状态\n  // 表示正在执行的chunk，加入到 resolves 数组中\n  if(installedChunks[chunkId]) {\n    resolves.push(installedChunks[chunkId][0]);\n  }\n  // 标记成已经执行完\n  installedChunks[chunkId] = 0;\n}\n```\n这里未执行的是非 0 状态，执行完就设置为0\n\ninstalledChunks[chunkId][0] 实际上就是 Promise 构造函数中的 resolve\n\n```\n// __webpack_require__.e \nvar promise = new Promise(function(resolve, reject) {\n\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n});\n```\n\n挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中\n\n\n原始的数组 push 方法，将 data 加入 window[\"webpackJsonp\"] 数组\n\n\n执行各个 resolves 方法，告诉 __webpack_require__.e 中回调函数的状态\n\n只有当这个方法执行完成的时候，我们才知道 JSONP 成功与否，也就是script.onload/onerror 会在 webpackJsonpCallback 之后执行。所以 onload/onerror 其实是用来检查 webpackJsonpCallback 的完成度：有没有将 installedChunks 中对应的 chunk 值设为 0\n\n大致的流程如下图所示\n\n[image.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/234b9478b2764bddbeee6c539d85c4ff~tplv-k3u1fbpfcp-zoom-1.image)","slug":"webpack打包后的代码是怎么样的","published":1,"updated":"2021-04-26T12:34:35.987Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvj0006sgcmau7fases","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir webpack</span><br><span class=\"line\"><span class=\"built_in\">cd</span> webpack</span><br><span class=\"line\">npm init -y</span><br><span class=\"line\">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure>\n<p>根目录中新建文件webpack.config.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path &#x3D; require(&#39;path&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    mode: &#39;development&#39;, &#x2F;&#x2F; 环境</span><br><span class=\"line\">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,&#x2F;&#x2F; 入口</span><br><span class=\"line\">    output: &#123;&#x2F;&#x2F;出口</span><br><span class=\"line\">        filename: &#39;bundle.js&#39;,</span><br><span class=\"line\">        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: &#39;cheap-source-map&#39;&#x2F;&#x2F; 为了更加方便查看输出</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在package.json中加入启动webpack的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,</span><br><span class=\"line\">  &quot;build&quot;: &quot;webpack&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新建一个 src文件夹，新增 index.js 文件<br>执行yarn build</p>\n<h2 id=\"分析主流程\"><a href=\"#分析主流程\" class=\"headerlink\" title=\"分析主流程\"></a>分析主流程</h2><h3 id=\"IFFE\"><a href=\"#IFFE\" class=\"headerlink\" title=\"IFFE\"></a>IFFE</h3><p>看输出的文件，整体上是一个IIFE(立即执行函数)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(modules) &#123; &#x2F;&#x2F; webpackBootstrap</span><br><span class=\"line\">\t&#x2F;&#x2F; The module cache</span><br><span class=\"line\">\tvar installedModules &#x3D; &#123;&#125;;</span><br><span class=\"line\">\tfunction __webpack_require__(moduleId) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...省略细节</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 入口文件</span><br><span class=\"line\">\treturn __webpack_require__(__webpack_require__.s &#x3D; &quot;.&#x2F;src&#x2F;index.js&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;.&#x2F;src&#x2F;index.js&quot;: (function(module, __webpack_exports__, __webpack_require__) &#123;&#125;),</span><br><span class=\"line\">  &quot;.&#x2F;src&#x2F;sayHello.js&quot;: (function(module, __webpack_exports__, __webpack_require__) &#123;&#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数的入参modules是一个对象，对象的key就是每个js模块的相对路径，value就是模块函数。</p>\n<p>IIFE会先require入口模块，然后入口模块会在执行时require其他模块，从而不断加载所需要的模块，形成依赖树</p>\n<h3 id=\"重要的实现机制——-webpack-require\"><a href=\"#重要的实现机制——-webpack-require\" class=\"headerlink\" title=\"重要的实现机制——__webpack_require__\"></a>重要的实现机制——__webpack_require__</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 缓存模块使用</span><br><span class=\"line\">var installedModules &#x3D; &#123;&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; The require function</span><br><span class=\"line\">&#x2F;&#x2F; 模拟模块的加载，webpack 实现的 require</span><br><span class=\"line\">function __webpack_require__(moduleId) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; Check if module is in cache</span><br><span class=\"line\">  &#x2F;&#x2F; 检查模块是否在缓存中，有则直接从缓存中获取</span><br><span class=\"line\">  if(installedModules[moduleId]) &#123;</span><br><span class=\"line\">    return installedModules[moduleId].exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; Create a new module (and put it into the cache)</span><br><span class=\"line\">  &#x2F;&#x2F; 没有则创建并放入缓存中，其中 key 值就是模块 Id,也就是上面所说的文件路径</span><br><span class=\"line\">  var module &#x3D; installedModules[moduleId] &#x3D; &#123;</span><br><span class=\"line\">    i: moduleId, &#x2F;&#x2F; Module ID</span><br><span class=\"line\">    l: false, &#x2F;&#x2F; 是否已经执行</span><br><span class=\"line\">    exports: &#123;&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Execute the module function</span><br><span class=\"line\">  &#x2F;&#x2F; 执行模块函数，挂载到 module.exports 上。this 指向 module.exports</span><br><span class=\"line\">  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Flag the module as loaded</span><br><span class=\"line\">  &#x2F;&#x2F; 标记这个 module 已经被加载</span><br><span class=\"line\">  module.l &#x3D; true;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Return the exports of the module</span><br><span class=\"line\">  &#x2F;&#x2F; module.exports通过在执行module的时候，作为参数存进去，然后会保存module中暴露给外界的接口，如函数、变量等</span><br><span class=\"line\">  return module.exports;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一步，webpack 这里做了一层优化，通过对象 installedModules 进行缓存，检查模块是否在缓存中，有则直接从缓存中获取，没有则创建并放入缓存中，其中 key 值就是模块 Id，也就是上面所说的文件路径</p>\n<p>第二步，然后执行模块函数，将 module, module.exports, __webpack_require__ 作为参数传递，并把模块的函数调用对象指向 module.exports，保证模块中的 this 指向永远指向当前的模块。</p>\n<p>第三步，最后返回加载的模块，调用方直接调用即可。</p>\n<p>所以这个__webpack_require__就是来加载一个模块，并在最后返回模块 module.exports 变量</p>\n<h3 id=\"webpack-是如何支持-ESM-的\"><a href=\"#webpack-是如何支持-ESM-的\" class=\"headerlink\" title=\"webpack 是如何支持 ESM 的\"></a>webpack 是如何支持 ESM 的</h3><h4 id=\"webpack-require-r-函数\"><a href=\"#webpack-require-r-函数\" class=\"headerlink\" title=\"__webpack_require__.r 函数\"></a>__webpack_require__.r 函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_require__.r &#x3D; (exports) &#x3D;&gt; &#123;</span><br><span class=\"line\"> \tif(typeof Symbol !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; Symbol.toStringTag) &#123;</span><br><span class=\"line\">        Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &#39;Module&#39; &#125;);</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\"> \tObject.defineProperty(exports, &#39;__esModule&#39;, &#123; value: true &#125;);</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>就是为__webpack_exports__ 添加__esModule属性 值为true</p>\n<h4 id=\"webpack-require-n-函数\"><a href=\"#webpack-require-n-函数\" class=\"headerlink\" title=\"__webpack_require__.n 函数\"></a>__webpack_require__.n 函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_require__.n &#x3D; (module) &#x3D;&gt; &#123;</span><br><span class=\"line\"> \tvar getter &#x3D; module &amp;&amp; module.__esModule ?</span><br><span class=\"line\">        () &#x3D;&gt; (module[&#39;default&#39;]) :</span><br><span class=\"line\">        () &#x3D;&gt; (module);</span><br><span class=\"line\"> \t__webpack_require__.d(getter, &#123; a: getter &#125;);</span><br><span class=\"line\"> \treturn getter;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>__webpack_require__.n会判断modules是否为es模块，当__esModule为true时，标识module为es模块，默认返回module[‘default’]，否则返回module</p>\n<h4 id=\"webpack-require-d\"><a href=\"#webpack-require-d\" class=\"headerlink\" title=\"__webpack_require__.d\"></a>__webpack_require__.d</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_require__.d &#x3D; (exports, definition) &#x3D;&gt; &#123;</span><br><span class=\"line\">\tfor(var key in definition) &#123;</span><br><span class=\"line\">\t\tif(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) &#123;</span><br><span class=\"line\">\t\t\tObject.defineProperty(exports, key, &#123; enumerable: true, get: definition[key] &#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>__webpack_require__.d主要的工作就是将上面的 getter 函数绑定到 exports 中的属性 a 的 getter 上</p>\n<p>打包后的模块函数。可以看出导出的是<strong>webpack_exports__[“default”]，实际上就是 __webpack_require</strong>.n 做了一层包装来实现的，其实也可以看出，实际上 webpack 是可以支持 CommonJS 和 ES Module 一起混用的</p>\n<h2 id=\"动态导入\"><a href=\"#动态导入\" class=\"headerlink\" title=\"动态导入\"></a>动态导入</h2><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>\n<p>常见的代码分割有以下几种方法：</p>\n<p>入口起点：使用 entry 配置手动地分离代码。<br>防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。<br>动态导入：通过模块的内联函数调用来分离代码。</p>\n<h3 id=\"webpack-require-e-——使用-JSONP-动态加载\"><a href=\"#webpack-require-e-——使用-JSONP-动态加载\" class=\"headerlink\" title=\"__webpack_require__.e ——使用 JSONP 动态加载\"></a>__webpack_require__.e ——使用 JSONP 动态加载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 已加载的chunk缓存</span><br><span class=\"line\">var installedChunks &#x3D; &#123;</span><br><span class=\"line\">  &quot;main&quot;: 0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; ...</span><br><span class=\"line\">__webpack_require__.e &#x3D; function requireEnsure(chunkId) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; promises 队列，等待多个异步 chunk 都加载完成才执行回调</span><br><span class=\"line\">  var promises &#x3D; [];</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; JSONP chunk loading for javascript</span><br><span class=\"line\">  var installedChunkData &#x3D; installedChunks[chunkId];</span><br><span class=\"line\">  &#x2F;&#x2F; 0 代表已经 installed</span><br><span class=\"line\">  if(installedChunkData !&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 0 means &quot;already installed&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; a Promise means &quot;currently loading&quot;.</span><br><span class=\"line\">    &#x2F;&#x2F; 目标chunk正在加载，则将 promise push到 promises 数组</span><br><span class=\"line\">    if(installedChunkData) &#123;</span><br><span class=\"line\">      promises.push(installedChunkData[2]);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; setup Promise in chunk cache</span><br><span class=\"line\">      &#x2F;&#x2F; 利用Promise去异步加载目标chunk</span><br><span class=\"line\">      var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 设置 installedChunks[chunkId]</span><br><span class=\"line\">        installedChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      &#x2F;&#x2F; i设置chunk加载的三种状态并缓存在 installedChunks 中，防止chunk重复加载</span><br><span class=\"line\">      &#x2F;&#x2F; nstalledChunks[chunkId]  &#x3D; [resolve, reject, promise]</span><br><span class=\"line\">      promises.push(installedChunkData[2] &#x3D; promise);</span><br><span class=\"line\">      &#x2F;&#x2F; start chunk loading</span><br><span class=\"line\">      &#x2F;&#x2F; 使用 JSONP</span><br><span class=\"line\">      var head &#x3D; document.getElementsByTagName(&#39;head&#39;)[0];</span><br><span class=\"line\">      var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">      script.charset &#x3D; &#39;utf-8&#39;;</span><br><span class=\"line\">      script.timeout &#x3D; 120;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (__webpack_require__.nc) &#123;</span><br><span class=\"line\">        script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &#x2F;&#x2F; 获取目标chunk的地址，__webpack_require__.p 表示设置的publicPath，默认为空串</span><br><span class=\"line\">      script.src &#x3D; __webpack_require__.p + &quot;&quot; + chunkId + &quot;.bundle.js&quot;;</span><br><span class=\"line\">      &#x2F;&#x2F; 请求超时的时候直接调用方法结束，时间为 120 s</span><br><span class=\"line\">      var timeout &#x3D; setTimeout(function()&#123;</span><br><span class=\"line\">        onScriptComplete(&#123; type: &#39;timeout&#39;, target: script &#125;);</span><br><span class=\"line\">      &#125;, 120000);</span><br><span class=\"line\">      script.onerror &#x3D; script.onload &#x3D; onScriptComplete;</span><br><span class=\"line\">      &#x2F;&#x2F; 设置加载完成或者错误的回调</span><br><span class=\"line\">      function onScriptComplete(event) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; avoid mem leaks in IE.</span><br><span class=\"line\">        &#x2F;&#x2F; 防止 IE 内存泄露</span><br><span class=\"line\">        script.onerror &#x3D; script.onload &#x3D; null;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        var chunk &#x3D; installedChunks[chunkId];</span><br><span class=\"line\">        &#x2F;&#x2F; 如果为 0 则表示已加载，主要逻辑看 webpackJsonpCallback 函数</span><br><span class=\"line\">        if(chunk !&#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">          if(chunk) &#123;</span><br><span class=\"line\">            var errorType &#x3D; event &amp;&amp; (event.type &#x3D;&#x3D;&#x3D; &#39;load&#39; ? &#39;missing&#39; : event.type);</span><br><span class=\"line\">            var realSrc &#x3D; event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class=\"line\">            var error &#x3D; new Error(&#39;Loading chunk &#39; + chunkId + &#39; failed.\\n(&#39; + errorType + &#39;: &#39; + realSrc + &#39;)&#39;);</span><br><span class=\"line\">            error.type &#x3D; errorType;</span><br><span class=\"line\">            error.request &#x3D; realSrc;</span><br><span class=\"line\">            chunk[1](error);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          installedChunks[chunkId] &#x3D; undefined;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      head.appendChild(script);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return Promise.all(promises);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看出将 import() 转换成模拟 JSONP 去加载动态加载的 chunk 文件</p>\n<p>设置 chunk 加载的三种状态并缓存在installedChunks中，防止chunk重复加载。这些状态的改变会在 webpackJsonpCallback 中提到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 设置 installedChunks[chunkId]</span><br><span class=\"line\">installedChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br></pre></td></tr></table></figure>\n<p>installedChunks[chunkId]为0，代表该 chunk 已经加载完毕<br>installedChunks[chunkId]为undefined，代表该 chunk 加载失败、加载超时、从未加载过<br>installedChunks[chunkId]为Promise对象，代表该 chunk 正在加载</p>\n<p>看完__webpack_require__.e，我们知道的是，我们通过 JSONP 去动态引入 chunk 文件，并根据引入的结果状态进行处理，那么我们怎么知道引入之后的状态呢？我们来看异步加载的 chunk 是怎样的</p>\n<h3 id=\"异步-Chunk\"><a href=\"#异步-Chunk\" class=\"headerlink\" title=\"异步 Chunk\"></a>异步 Chunk</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; window[&quot;webpackJsonp&quot;] 实际上是一个数组，向中添加一个元素。这个元素也是一个数组，其中数组的第一个元素是chunkId，第二个对象，跟传入到 IIFE 中的参数一样</span><br><span class=\"line\">(window[&quot;webpackJsonp&quot;] &#x3D; window[&quot;webpackJsonp&quot;] || []).push([[0],&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;***&#x2F; &quot;.&#x2F;src&#x2F;Another.js&quot;:</span><br><span class=\"line\">  &#x2F;***&#x2F; (function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &quot;use strict&quot;;</span><br><span class=\"line\">  __webpack_require__.r(__webpack_exports__);</span><br><span class=\"line\">  &#x2F;* harmony export (binding) *&#x2F; __webpack_require__.d(__webpack_exports__, &quot;Another&quot;, function() &#123; return Another; &#125;);</span><br><span class=\"line\">  function Another() &#123;</span><br><span class=\"line\">    return &#39;Hi, I am Another Module&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;***&#x2F; &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  &#125;]);</span><br><span class=\"line\">  &#x2F;&#x2F;# sourceMappingURL&#x3D;0.bundle.js.map</span><br></pre></td></tr></table></figure>\n<p>主要做的事情就是往一个数组 window[‘webpackJsonp’] 中塞入一个元素，这个元素也是一个数组，其中数组的第一个元素是 chunkId，第二个对象，跟主 chunk 中 IIFE 传入的参数类似。关键是这个 window[‘webpackJsonp’] 在哪里会用到呢？我们回到主 chunk 中。在 return <strong>webpack_require__(__webpack_require</strong>.s = “./src/index.js”); 进入入口之前还有一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var jsonpArray &#x3D; window[&quot;webpackJsonp&quot;] &#x3D; window[&quot;webpackJsonp&quot;] || [];</span><br><span class=\"line\">&#x2F;&#x2F; 保存原始的 Array.prototype.push 方法</span><br><span class=\"line\">var oldJsonpFunction &#x3D; jsonpArray.push.bind(jsonpArray);</span><br><span class=\"line\">&#x2F;&#x2F; 将 push 方法的实现修改为 webpackJsonpCallback</span><br><span class=\"line\">&#x2F;&#x2F; 这样我们在异步 chunk 中执行的 window[&#39;webpackJsonp&#39;].push 其实是 webpackJsonpCallback 函数。</span><br><span class=\"line\">jsonpArray.push &#x3D; webpackJsonpCallback;</span><br><span class=\"line\">jsonpArray &#x3D; jsonpArray.slice();</span><br><span class=\"line\">&#x2F;&#x2F; 对已在数组中的元素依次执行webpackJsonpCallback方法</span><br><span class=\"line\">for(var i &#x3D; 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class=\"line\">var parentJsonpFunction &#x3D; oldJsonpFunction;</span><br></pre></td></tr></table></figure>\n<p>jsonpArray 就是 window[“webpackJsonp”] ，重点看下面这一句代码，当执行 push 方法的时候，就会执行 webpackJsonpCallback，相当于做了一层劫持，也就是执行完 push 操作的时候就会调用这个函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonpArray.push &#x3D; webpackJsonpCallback;</span><br></pre></td></tr></table></figure>\n<p>webpackJsonpCallback ——加载完动态 chunk 之后的回调<br>我们再来看看  webpackJsonpCallback 函数，这里的入参就是动态加载的 chunk 的 window[‘webpackJsonp’] push 进去的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var installedChunks &#x3D; &#123;</span><br><span class=\"line\">  &quot;main&quot;: 0</span><br><span class=\"line\">&#125;;\t</span><br><span class=\"line\"></span><br><span class=\"line\">function webpackJsonpCallback(data) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; window[&quot;webpackJsonp&quot;] 中的第一个参数——即[0]</span><br><span class=\"line\">  var chunkIds &#x3D; data[0];</span><br><span class=\"line\">  &#x2F;&#x2F; 对应的模块详细信息，详见打包出来的 chunk 模块中的 push 进 window[&quot;webpackJsonp&quot;] 中的第二个参数</span><br><span class=\"line\">  var moreModules &#x3D; data[1];</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; add &quot;moreModules&quot; to the modules object,</span><br><span class=\"line\">  &#x2F;&#x2F; then flag all &quot;chunkIds&quot; as loaded and fire callback</span><br><span class=\"line\">  var moduleId, chunkId, i &#x3D; 0, resolves &#x3D; [];</span><br><span class=\"line\">  for(;i &lt; chunkIds.length; i++) &#123;</span><br><span class=\"line\">    chunkId &#x3D; chunkIds[i];</span><br><span class=\"line\">    &#x2F;&#x2F; 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]</span><br><span class=\"line\">    &#x2F;&#x2F; 这个可以看 __webpack_require__.e 中设置的状态</span><br><span class=\"line\">    &#x2F;&#x2F; 表示正在执行的chunk，加入到 resolves 数组中</span><br><span class=\"line\">    if(installedChunks[chunkId]) &#123;</span><br><span class=\"line\">      resolves.push(installedChunks[chunkId][0]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 标记成已经执行完</span><br><span class=\"line\">    installedChunks[chunkId] &#x3D; 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中</span><br><span class=\"line\">  for(moduleId in moreModules) &#123;</span><br><span class=\"line\">    if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">      modules[moduleId] &#x3D; moreModules[moduleId];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; parentJsonpFunction: 原始的数组 push 方法，将 data 加入 window[&quot;webpackJsonp&quot;] 数组。</span><br><span class=\"line\">  if(parentJsonpFunction) parentJsonpFunction(data);</span><br><span class=\"line\">  &#x2F;&#x2F; 等到 while 循环结束后，__webpack_require__.e 的返回值 Promise 得到 resolve</span><br><span class=\"line\">  &#x2F;&#x2F; 执行 resolove</span><br><span class=\"line\">  while(resolves.length) &#123;</span><br><span class=\"line\">    resolves.shift()();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当我们 JSONP 去加载异步 chunk 完成之后，就会去执行 window[“webpackJsonp”] || []).push，也就是 webpackJsonpCallback。主要有以下几步</p>\n<p>遍历要加载的 chunkIds，找到未执行完的 chunk，并加入到 resolves 中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(;i &lt; chunkIds.length; i++) &#123;</span><br><span class=\"line\">  chunkId &#x3D; chunkIds[i];</span><br><span class=\"line\">  &#x2F;&#x2F; 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]</span><br><span class=\"line\">  &#x2F;&#x2F; 这个可以看 __webpack_require__.e 中设置的状态</span><br><span class=\"line\">  &#x2F;&#x2F; 表示正在执行的chunk，加入到 resolves 数组中</span><br><span class=\"line\">  if(installedChunks[chunkId]) &#123;</span><br><span class=\"line\">    resolves.push(installedChunks[chunkId][0]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 标记成已经执行完</span><br><span class=\"line\">  installedChunks[chunkId] &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里未执行的是非 0 状态，执行完就设置为0</p>\n<p>installedChunks[chunkId][0] 实际上就是 Promise 构造函数中的 resolve</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; __webpack_require__.e </span><br><span class=\"line\">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">\tinstalledChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中</p>\n<p>原始的数组 push 方法，将 data 加入 window[“webpackJsonp”] 数组</p>\n<p>执行各个 resolves 方法，告诉 __webpack_require__.e 中回调函数的状态</p>\n<p>只有当这个方法执行完成的时候，我们才知道 JSONP 成功与否，也就是script.onload/onerror 会在 webpackJsonpCallback 之后执行。所以 onload/onerror 其实是用来检查 webpackJsonpCallback 的完成度：有没有将 installedChunks 中对应的 chunk 值设为 0</p>\n<p>大致的流程如下图所示</p>\n<p><a href=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/234b9478b2764bddbeee6c539d85c4ff~tplv-k3u1fbpfcp-zoom-1.image\">image.jpg</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir webpack</span><br><span class=\"line\"><span class=\"built_in\">cd</span> webpack</span><br><span class=\"line\">npm init -y</span><br><span class=\"line\">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure>\n<p>根目录中新建文件webpack.config.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const path &#x3D; require(&#39;path&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    mode: &#39;development&#39;, &#x2F;&#x2F; 环境</span><br><span class=\"line\">    entry: &#39;.&#x2F;src&#x2F;index.js&#39;,&#x2F;&#x2F; 入口</span><br><span class=\"line\">    output: &#123;&#x2F;&#x2F;出口</span><br><span class=\"line\">        filename: &#39;bundle.js&#39;,</span><br><span class=\"line\">        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: &#39;cheap-source-map&#39;&#x2F;&#x2F; 为了更加方便查看输出</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在package.json中加入启动webpack的命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">  &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;,</span><br><span class=\"line\">  &quot;build&quot;: &quot;webpack&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>新建一个 src文件夹，新增 index.js 文件<br>执行yarn build</p>\n<h2 id=\"分析主流程\"><a href=\"#分析主流程\" class=\"headerlink\" title=\"分析主流程\"></a>分析主流程</h2><h3 id=\"IFFE\"><a href=\"#IFFE\" class=\"headerlink\" title=\"IFFE\"></a>IFFE</h3><p>看输出的文件，整体上是一个IIFE(立即执行函数)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(modules) &#123; &#x2F;&#x2F; webpackBootstrap</span><br><span class=\"line\">\t&#x2F;&#x2F; The module cache</span><br><span class=\"line\">\tvar installedModules &#x3D; &#123;&#125;;</span><br><span class=\"line\">\tfunction __webpack_require__(moduleId) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...省略细节</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t&#x2F;&#x2F; 入口文件</span><br><span class=\"line\">\treturn __webpack_require__(__webpack_require__.s &#x3D; &quot;.&#x2F;src&#x2F;index.js&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">(&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"> &quot;.&#x2F;src&#x2F;index.js&quot;: (function(module, __webpack_exports__, __webpack_require__) &#123;&#125;),</span><br><span class=\"line\">  &quot;.&#x2F;src&#x2F;sayHello.js&quot;: (function(module, __webpack_exports__, __webpack_require__) &#123;&#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>函数的入参modules是一个对象，对象的key就是每个js模块的相对路径，value就是模块函数。</p>\n<p>IIFE会先require入口模块，然后入口模块会在执行时require其他模块，从而不断加载所需要的模块，形成依赖树</p>\n<h3 id=\"重要的实现机制——-webpack-require\"><a href=\"#重要的实现机制——-webpack-require\" class=\"headerlink\" title=\"重要的实现机制——__webpack_require__\"></a>重要的实现机制——__webpack_require__</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 缓存模块使用</span><br><span class=\"line\">var installedModules &#x3D; &#123;&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; The require function</span><br><span class=\"line\">&#x2F;&#x2F; 模拟模块的加载，webpack 实现的 require</span><br><span class=\"line\">function __webpack_require__(moduleId) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; Check if module is in cache</span><br><span class=\"line\">  &#x2F;&#x2F; 检查模块是否在缓存中，有则直接从缓存中获取</span><br><span class=\"line\">  if(installedModules[moduleId]) &#123;</span><br><span class=\"line\">    return installedModules[moduleId].exports;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; Create a new module (and put it into the cache)</span><br><span class=\"line\">  &#x2F;&#x2F; 没有则创建并放入缓存中，其中 key 值就是模块 Id,也就是上面所说的文件路径</span><br><span class=\"line\">  var module &#x3D; installedModules[moduleId] &#x3D; &#123;</span><br><span class=\"line\">    i: moduleId, &#x2F;&#x2F; Module ID</span><br><span class=\"line\">    l: false, &#x2F;&#x2F; 是否已经执行</span><br><span class=\"line\">    exports: &#123;&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Execute the module function</span><br><span class=\"line\">  &#x2F;&#x2F; 执行模块函数，挂载到 module.exports 上。this 指向 module.exports</span><br><span class=\"line\">  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Flag the module as loaded</span><br><span class=\"line\">  &#x2F;&#x2F; 标记这个 module 已经被加载</span><br><span class=\"line\">  module.l &#x3D; true;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; Return the exports of the module</span><br><span class=\"line\">  &#x2F;&#x2F; module.exports通过在执行module的时候，作为参数存进去，然后会保存module中暴露给外界的接口，如函数、变量等</span><br><span class=\"line\">  return module.exports;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一步，webpack 这里做了一层优化，通过对象 installedModules 进行缓存，检查模块是否在缓存中，有则直接从缓存中获取，没有则创建并放入缓存中，其中 key 值就是模块 Id，也就是上面所说的文件路径</p>\n<p>第二步，然后执行模块函数，将 module, module.exports, __webpack_require__ 作为参数传递，并把模块的函数调用对象指向 module.exports，保证模块中的 this 指向永远指向当前的模块。</p>\n<p>第三步，最后返回加载的模块，调用方直接调用即可。</p>\n<p>所以这个__webpack_require__就是来加载一个模块，并在最后返回模块 module.exports 变量</p>\n<h3 id=\"webpack-是如何支持-ESM-的\"><a href=\"#webpack-是如何支持-ESM-的\" class=\"headerlink\" title=\"webpack 是如何支持 ESM 的\"></a>webpack 是如何支持 ESM 的</h3><h4 id=\"webpack-require-r-函数\"><a href=\"#webpack-require-r-函数\" class=\"headerlink\" title=\"__webpack_require__.r 函数\"></a>__webpack_require__.r 函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_require__.r &#x3D; (exports) &#x3D;&gt; &#123;</span><br><span class=\"line\"> \tif(typeof Symbol !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; Symbol.toStringTag) &#123;</span><br><span class=\"line\">        Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &#39;Module&#39; &#125;);</span><br><span class=\"line\"> \t&#125;</span><br><span class=\"line\"> \tObject.defineProperty(exports, &#39;__esModule&#39;, &#123; value: true &#125;);</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>就是为__webpack_exports__ 添加__esModule属性 值为true</p>\n<h4 id=\"webpack-require-n-函数\"><a href=\"#webpack-require-n-函数\" class=\"headerlink\" title=\"__webpack_require__.n 函数\"></a>__webpack_require__.n 函数</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_require__.n &#x3D; (module) &#x3D;&gt; &#123;</span><br><span class=\"line\"> \tvar getter &#x3D; module &amp;&amp; module.__esModule ?</span><br><span class=\"line\">        () &#x3D;&gt; (module[&#39;default&#39;]) :</span><br><span class=\"line\">        () &#x3D;&gt; (module);</span><br><span class=\"line\"> \t__webpack_require__.d(getter, &#123; a: getter &#125;);</span><br><span class=\"line\"> \treturn getter;</span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>__webpack_require__.n会判断modules是否为es模块，当__esModule为true时，标识module为es模块，默认返回module[‘default’]，否则返回module</p>\n<h4 id=\"webpack-require-d\"><a href=\"#webpack-require-d\" class=\"headerlink\" title=\"__webpack_require__.d\"></a>__webpack_require__.d</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__webpack_require__.d &#x3D; (exports, definition) &#x3D;&gt; &#123;</span><br><span class=\"line\">\tfor(var key in definition) &#123;</span><br><span class=\"line\">\t\tif(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) &#123;</span><br><span class=\"line\">\t\t\tObject.defineProperty(exports, key, &#123; enumerable: true, get: definition[key] &#125;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>__webpack_require__.d主要的工作就是将上面的 getter 函数绑定到 exports 中的属性 a 的 getter 上</p>\n<p>打包后的模块函数。可以看出导出的是<strong>webpack_exports__[“default”]，实际上就是 __webpack_require</strong>.n 做了一层包装来实现的，其实也可以看出，实际上 webpack 是可以支持 CommonJS 和 ES Module 一起混用的</p>\n<h2 id=\"动态导入\"><a href=\"#动态导入\" class=\"headerlink\" title=\"动态导入\"></a>动态导入</h2><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>\n<p>常见的代码分割有以下几种方法：</p>\n<p>入口起点：使用 entry 配置手动地分离代码。<br>防止重复：使用 Entry dependencies 或者 SplitChunksPlugin 去重和分离 chunk。<br>动态导入：通过模块的内联函数调用来分离代码。</p>\n<h3 id=\"webpack-require-e-——使用-JSONP-动态加载\"><a href=\"#webpack-require-e-——使用-JSONP-动态加载\" class=\"headerlink\" title=\"__webpack_require__.e ——使用 JSONP 动态加载\"></a>__webpack_require__.e ——使用 JSONP 动态加载</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 已加载的chunk缓存</span><br><span class=\"line\">var installedChunks &#x3D; &#123;</span><br><span class=\"line\">  &quot;main&quot;: 0</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; ...</span><br><span class=\"line\">__webpack_require__.e &#x3D; function requireEnsure(chunkId) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; promises 队列，等待多个异步 chunk 都加载完成才执行回调</span><br><span class=\"line\">  var promises &#x3D; [];</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; JSONP chunk loading for javascript</span><br><span class=\"line\">  var installedChunkData &#x3D; installedChunks[chunkId];</span><br><span class=\"line\">  &#x2F;&#x2F; 0 代表已经 installed</span><br><span class=\"line\">  if(installedChunkData !&#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 0 means &quot;already installed&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; a Promise means &quot;currently loading&quot;.</span><br><span class=\"line\">    &#x2F;&#x2F; 目标chunk正在加载，则将 promise push到 promises 数组</span><br><span class=\"line\">    if(installedChunkData) &#123;</span><br><span class=\"line\">      promises.push(installedChunkData[2]);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      &#x2F;&#x2F; setup Promise in chunk cache</span><br><span class=\"line\">      &#x2F;&#x2F; 利用Promise去异步加载目标chunk</span><br><span class=\"line\">      var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 设置 installedChunks[chunkId]</span><br><span class=\"line\">        installedChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      &#x2F;&#x2F; i设置chunk加载的三种状态并缓存在 installedChunks 中，防止chunk重复加载</span><br><span class=\"line\">      &#x2F;&#x2F; nstalledChunks[chunkId]  &#x3D; [resolve, reject, promise]</span><br><span class=\"line\">      promises.push(installedChunkData[2] &#x3D; promise);</span><br><span class=\"line\">      &#x2F;&#x2F; start chunk loading</span><br><span class=\"line\">      &#x2F;&#x2F; 使用 JSONP</span><br><span class=\"line\">      var head &#x3D; document.getElementsByTagName(&#39;head&#39;)[0];</span><br><span class=\"line\">      var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">      script.charset &#x3D; &#39;utf-8&#39;;</span><br><span class=\"line\">      script.timeout &#x3D; 120;</span><br><span class=\"line\"></span><br><span class=\"line\">      if (__webpack_require__.nc) &#123;</span><br><span class=\"line\">        script.setAttribute(&quot;nonce&quot;, __webpack_require__.nc);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      &#x2F;&#x2F; 获取目标chunk的地址，__webpack_require__.p 表示设置的publicPath，默认为空串</span><br><span class=\"line\">      script.src &#x3D; __webpack_require__.p + &quot;&quot; + chunkId + &quot;.bundle.js&quot;;</span><br><span class=\"line\">      &#x2F;&#x2F; 请求超时的时候直接调用方法结束，时间为 120 s</span><br><span class=\"line\">      var timeout &#x3D; setTimeout(function()&#123;</span><br><span class=\"line\">        onScriptComplete(&#123; type: &#39;timeout&#39;, target: script &#125;);</span><br><span class=\"line\">      &#125;, 120000);</span><br><span class=\"line\">      script.onerror &#x3D; script.onload &#x3D; onScriptComplete;</span><br><span class=\"line\">      &#x2F;&#x2F; 设置加载完成或者错误的回调</span><br><span class=\"line\">      function onScriptComplete(event) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; avoid mem leaks in IE.</span><br><span class=\"line\">        &#x2F;&#x2F; 防止 IE 内存泄露</span><br><span class=\"line\">        script.onerror &#x3D; script.onload &#x3D; null;</span><br><span class=\"line\">        clearTimeout(timeout);</span><br><span class=\"line\">        var chunk &#x3D; installedChunks[chunkId];</span><br><span class=\"line\">        &#x2F;&#x2F; 如果为 0 则表示已加载，主要逻辑看 webpackJsonpCallback 函数</span><br><span class=\"line\">        if(chunk !&#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">          if(chunk) &#123;</span><br><span class=\"line\">            var errorType &#x3D; event &amp;&amp; (event.type &#x3D;&#x3D;&#x3D; &#39;load&#39; ? &#39;missing&#39; : event.type);</span><br><span class=\"line\">            var realSrc &#x3D; event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class=\"line\">            var error &#x3D; new Error(&#39;Loading chunk &#39; + chunkId + &#39; failed.\\n(&#39; + errorType + &#39;: &#39; + realSrc + &#39;)&#39;);</span><br><span class=\"line\">            error.type &#x3D; errorType;</span><br><span class=\"line\">            error.request &#x3D; realSrc;</span><br><span class=\"line\">            chunk[1](error);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          installedChunks[chunkId] &#x3D; undefined;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      head.appendChild(script);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return Promise.all(promises);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看出将 import() 转换成模拟 JSONP 去加载动态加载的 chunk 文件</p>\n<p>设置 chunk 加载的三种状态并缓存在installedChunks中，防止chunk重复加载。这些状态的改变会在 webpackJsonpCallback 中提到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 设置 installedChunks[chunkId]</span><br><span class=\"line\">installedChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br></pre></td></tr></table></figure>\n<p>installedChunks[chunkId]为0，代表该 chunk 已经加载完毕<br>installedChunks[chunkId]为undefined，代表该 chunk 加载失败、加载超时、从未加载过<br>installedChunks[chunkId]为Promise对象，代表该 chunk 正在加载</p>\n<p>看完__webpack_require__.e，我们知道的是，我们通过 JSONP 去动态引入 chunk 文件，并根据引入的结果状态进行处理，那么我们怎么知道引入之后的状态呢？我们来看异步加载的 chunk 是怎样的</p>\n<h3 id=\"异步-Chunk\"><a href=\"#异步-Chunk\" class=\"headerlink\" title=\"异步 Chunk\"></a>异步 Chunk</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; window[&quot;webpackJsonp&quot;] 实际上是一个数组，向中添加一个元素。这个元素也是一个数组，其中数组的第一个元素是chunkId，第二个对象，跟传入到 IIFE 中的参数一样</span><br><span class=\"line\">(window[&quot;webpackJsonp&quot;] &#x3D; window[&quot;webpackJsonp&quot;] || []).push([[0],&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;***&#x2F; &quot;.&#x2F;src&#x2F;Another.js&quot;:</span><br><span class=\"line\">  &#x2F;***&#x2F; (function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  &quot;use strict&quot;;</span><br><span class=\"line\">  __webpack_require__.r(__webpack_exports__);</span><br><span class=\"line\">  &#x2F;* harmony export (binding) *&#x2F; __webpack_require__.d(__webpack_exports__, &quot;Another&quot;, function() &#123; return Another; &#125;);</span><br><span class=\"line\">  function Another() &#123;</span><br><span class=\"line\">    return &#39;Hi, I am Another Module&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;***&#x2F; &#125;)</span><br><span class=\"line\">  </span><br><span class=\"line\">  &#125;]);</span><br><span class=\"line\">  &#x2F;&#x2F;# sourceMappingURL&#x3D;0.bundle.js.map</span><br></pre></td></tr></table></figure>\n<p>主要做的事情就是往一个数组 window[‘webpackJsonp’] 中塞入一个元素，这个元素也是一个数组，其中数组的第一个元素是 chunkId，第二个对象，跟主 chunk 中 IIFE 传入的参数类似。关键是这个 window[‘webpackJsonp’] 在哪里会用到呢？我们回到主 chunk 中。在 return <strong>webpack_require__(__webpack_require</strong>.s = “./src/index.js”); 进入入口之前还有一段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var jsonpArray &#x3D; window[&quot;webpackJsonp&quot;] &#x3D; window[&quot;webpackJsonp&quot;] || [];</span><br><span class=\"line\">&#x2F;&#x2F; 保存原始的 Array.prototype.push 方法</span><br><span class=\"line\">var oldJsonpFunction &#x3D; jsonpArray.push.bind(jsonpArray);</span><br><span class=\"line\">&#x2F;&#x2F; 将 push 方法的实现修改为 webpackJsonpCallback</span><br><span class=\"line\">&#x2F;&#x2F; 这样我们在异步 chunk 中执行的 window[&#39;webpackJsonp&#39;].push 其实是 webpackJsonpCallback 函数。</span><br><span class=\"line\">jsonpArray.push &#x3D; webpackJsonpCallback;</span><br><span class=\"line\">jsonpArray &#x3D; jsonpArray.slice();</span><br><span class=\"line\">&#x2F;&#x2F; 对已在数组中的元素依次执行webpackJsonpCallback方法</span><br><span class=\"line\">for(var i &#x3D; 0; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class=\"line\">var parentJsonpFunction &#x3D; oldJsonpFunction;</span><br></pre></td></tr></table></figure>\n<p>jsonpArray 就是 window[“webpackJsonp”] ，重点看下面这一句代码，当执行 push 方法的时候，就会执行 webpackJsonpCallback，相当于做了一层劫持，也就是执行完 push 操作的时候就会调用这个函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jsonpArray.push &#x3D; webpackJsonpCallback;</span><br></pre></td></tr></table></figure>\n<p>webpackJsonpCallback ——加载完动态 chunk 之后的回调<br>我们再来看看  webpackJsonpCallback 函数，这里的入参就是动态加载的 chunk 的 window[‘webpackJsonp’] push 进去的参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var installedChunks &#x3D; &#123;</span><br><span class=\"line\">  &quot;main&quot;: 0</span><br><span class=\"line\">&#125;;\t</span><br><span class=\"line\"></span><br><span class=\"line\">function webpackJsonpCallback(data) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; window[&quot;webpackJsonp&quot;] 中的第一个参数——即[0]</span><br><span class=\"line\">  var chunkIds &#x3D; data[0];</span><br><span class=\"line\">  &#x2F;&#x2F; 对应的模块详细信息，详见打包出来的 chunk 模块中的 push 进 window[&quot;webpackJsonp&quot;] 中的第二个参数</span><br><span class=\"line\">  var moreModules &#x3D; data[1];</span><br><span class=\"line\"></span><br><span class=\"line\">  &#x2F;&#x2F; add &quot;moreModules&quot; to the modules object,</span><br><span class=\"line\">  &#x2F;&#x2F; then flag all &quot;chunkIds&quot; as loaded and fire callback</span><br><span class=\"line\">  var moduleId, chunkId, i &#x3D; 0, resolves &#x3D; [];</span><br><span class=\"line\">  for(;i &lt; chunkIds.length; i++) &#123;</span><br><span class=\"line\">    chunkId &#x3D; chunkIds[i];</span><br><span class=\"line\">    &#x2F;&#x2F; 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]</span><br><span class=\"line\">    &#x2F;&#x2F; 这个可以看 __webpack_require__.e 中设置的状态</span><br><span class=\"line\">    &#x2F;&#x2F; 表示正在执行的chunk，加入到 resolves 数组中</span><br><span class=\"line\">    if(installedChunks[chunkId]) &#123;</span><br><span class=\"line\">      resolves.push(installedChunks[chunkId][0]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 标记成已经执行完</span><br><span class=\"line\">    installedChunks[chunkId] &#x3D; 0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中</span><br><span class=\"line\">  for(moduleId in moreModules) &#123;</span><br><span class=\"line\">    if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">      modules[moduleId] &#x3D; moreModules[moduleId];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; parentJsonpFunction: 原始的数组 push 方法，将 data 加入 window[&quot;webpackJsonp&quot;] 数组。</span><br><span class=\"line\">  if(parentJsonpFunction) parentJsonpFunction(data);</span><br><span class=\"line\">  &#x2F;&#x2F; 等到 while 循环结束后，__webpack_require__.e 的返回值 Promise 得到 resolve</span><br><span class=\"line\">  &#x2F;&#x2F; 执行 resolove</span><br><span class=\"line\">  while(resolves.length) &#123;</span><br><span class=\"line\">    resolves.shift()();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>当我们 JSONP 去加载异步 chunk 完成之后，就会去执行 window[“webpackJsonp”] || []).push，也就是 webpackJsonpCallback。主要有以下几步</p>\n<p>遍历要加载的 chunkIds，找到未执行完的 chunk，并加入到 resolves 中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for(;i &lt; chunkIds.length; i++) &#123;</span><br><span class=\"line\">  chunkId &#x3D; chunkIds[i];</span><br><span class=\"line\">  &#x2F;&#x2F; 所以此处是找到那些未加载完的chunk，他们的value还是[resolve, reject, promise]</span><br><span class=\"line\">  &#x2F;&#x2F; 这个可以看 __webpack_require__.e 中设置的状态</span><br><span class=\"line\">  &#x2F;&#x2F; 表示正在执行的chunk，加入到 resolves 数组中</span><br><span class=\"line\">  if(installedChunks[chunkId]) &#123;</span><br><span class=\"line\">    resolves.push(installedChunks[chunkId][0]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#x2F;&#x2F; 标记成已经执行完</span><br><span class=\"line\">  installedChunks[chunkId] &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里未执行的是非 0 状态，执行完就设置为0</p>\n<p>installedChunks[chunkId][0] 实际上就是 Promise 构造函数中的 resolve</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; __webpack_require__.e </span><br><span class=\"line\">var promise &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class=\"line\">\tinstalledChunkData &#x3D; installedChunks[chunkId] &#x3D; [resolve, reject];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>挨个将异步 chunk 中的 module 加入主 chunk 的 modules 数组中</p>\n<p>原始的数组 push 方法，将 data 加入 window[“webpackJsonp”] 数组</p>\n<p>执行各个 resolves 方法，告诉 __webpack_require__.e 中回调函数的状态</p>\n<p>只有当这个方法执行完成的时候，我们才知道 JSONP 成功与否，也就是script.onload/onerror 会在 webpackJsonpCallback 之后执行。所以 onload/onerror 其实是用来检查 webpackJsonpCallback 的完成度：有没有将 installedChunks 中对应的 chunk 值设为 0</p>\n<p>大致的流程如下图所示</p>\n<p><a href=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/234b9478b2764bddbeee6c539d85c4ff~tplv-k3u1fbpfcp-zoom-1.image\">image.jpg</a></p>\n"},{"title":"算法题1","date":"2021-04-20T12:04:07.000Z","_content":"## 题目（中等）\n\n二维数组中的查找\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的\n一个二维数组和一个整数，判断数组中是否含有该整数。\n\n## 思路\n\n1.使用两层循环遍历，时间复杂度o(n^2)\n\n2.利用递增的特定，可以从左上角开始遍历，当前数值比所求的值小，向右，当前数值比所求的值大，向上，时间复杂度o(n)\n\n## 代码\n```\n var findNumber = function(matrix,target){\n    if(!matrix.length) return false;\n    let x = matrix.length - 1,y=0;\n    while(x>=0;y < matrix[0].length){\n        if(matrix[x][y] === target){\n            return true;\n        }else if (matrix[x][y] > target){\n            x--\n        }else {\n            y++\n        }\n    }\n} \n```","source":"_posts/算法题1.md","raw":"---\ntitle: 算法题1\ndate: 2021-04-20 20:04:07\ntags: 算法\ncategories: 每日一题\n---\n## 题目（中等）\n\n二维数组中的查找\n\n在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的\n一个二维数组和一个整数，判断数组中是否含有该整数。\n\n## 思路\n\n1.使用两层循环遍历，时间复杂度o(n^2)\n\n2.利用递增的特定，可以从左上角开始遍历，当前数值比所求的值小，向右，当前数值比所求的值大，向上，时间复杂度o(n)\n\n## 代码\n```\n var findNumber = function(matrix,target){\n    if(!matrix.length) return false;\n    let x = matrix.length - 1,y=0;\n    while(x>=0;y < matrix[0].length){\n        if(matrix[x][y] === target){\n            return true;\n        }else if (matrix[x][y] > target){\n            x--\n        }else {\n            y++\n        }\n    }\n} \n```","slug":"算法题1","published":1,"updated":"2021-04-23T06:45:08.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvk0007sgcm31q7eaj3","content":"<h2 id=\"题目（中等）\"><a href=\"#题目（中等）\" class=\"headerlink\" title=\"题目（中等）\"></a>题目（中等）</h2><p>二维数组中的查找</p>\n<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的<br>一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>1.使用两层循环遍历，时间复杂度o(n^2)</p>\n<p>2.利用递增的特定，可以从左上角开始遍历，当前数值比所求的值小，向右，当前数值比所求的值大，向上，时间复杂度o(n)</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var findNumber &#x3D; function(matrix,target)&#123;</span><br><span class=\"line\">    if(!matrix.length) return false;</span><br><span class=\"line\">    let x &#x3D; matrix.length - 1,y&#x3D;0;</span><br><span class=\"line\">    while(x&gt;&#x3D;0;y &lt; matrix[0].length)&#123;</span><br><span class=\"line\">        if(matrix[x][y] &#x3D;&#x3D;&#x3D; target)&#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;else if (matrix[x][y] &gt; target)&#123;</span><br><span class=\"line\">            x--</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            y++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"题目（中等）\"><a href=\"#题目（中等）\" class=\"headerlink\" title=\"题目（中等）\"></a>题目（中等）</h2><p>二维数组中的查找</p>\n<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的<br>一个二维数组和一个整数，判断数组中是否含有该整数。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>1.使用两层循环遍历，时间复杂度o(n^2)</p>\n<p>2.利用递增的特定，可以从左上角开始遍历，当前数值比所求的值小，向右，当前数值比所求的值大，向上，时间复杂度o(n)</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> var findNumber &#x3D; function(matrix,target)&#123;</span><br><span class=\"line\">    if(!matrix.length) return false;</span><br><span class=\"line\">    let x &#x3D; matrix.length - 1,y&#x3D;0;</span><br><span class=\"line\">    while(x&gt;&#x3D;0;y &lt; matrix[0].length)&#123;</span><br><span class=\"line\">        if(matrix[x][y] &#x3D;&#x3D;&#x3D; target)&#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;else if (matrix[x][y] &gt; target)&#123;</span><br><span class=\"line\">            x--</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            y++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>"},{"title":"机器学习","date":"2021-04-14T07:12:59.000Z","_content":"## 什么是机器学习\n\n你可能每天用到它许多次却不知道它。 每次你用谷歌或者必应搜索，它们很好用 是因为它们的机器学习软件已经计算出如何对网页排名 脸书或者苹果的照片应用在照片中识别出你的朋友， 这也是机器学习。 每次你阅读你的邮件 垃圾邮件过滤器把你从海量的垃圾邮件中解救出来， 这也是因为你的计算机学习了如何从非垃圾邮件中辨别垃圾邮件。 这就是机器学习。 这是一门是让计算机 无需显式编程 (explicitly programmed) 就能自主学习的学科。 我正在做的其中一个研究项目是让机器人去 整理房间。 你要怎样去做这个？ 你能做的是使机器人看你的演示任务和 从中学习。 机器人会看你拿起了什么东西，放在了哪里 试着去做同样的事情，即使在你不在的时候。 我对此感到兴奋的原因之一是 AI ，即 人工智能问题。 建立真正的智能机器， 就可以做任何你和我也能做的事情。 许多科学家认为在这方面取得进展的最好方法 是通过一种叫做神经网络的学习算法 这种算法模仿人类大脑的工作过程， 之后我也会教你。\n\n## TensorFlow.js\n\nTensorFlow.js 是Google将机器学习(Machine Learning)TensorFlow框架的JavaScript版本，通过TensorFlow.js，让JavaScript开发人员也有机会加入机器学习的领域。加上前端领域的生态圈支持，让机器学习在浏览器上有了更多发挥的空间！例如结合摄影机、移动设备的陀螺仪等等，只要设备与浏览器支援，都能够发生更多不同的变化，同时借由在客户端浏览器上执行的优势，节省后端学习的成本。\n\n## TensorFlow.js的特色与基本组成\n\n由于TensorFlow.js是由JavaScript编写而成，因此只要与浏览器相关的应用，都可以与TensorFlow.js直接整合，这意味着我们可以将浏览器功能与机器学习搭配起来，组合成更多元的Web Application。\nTensorFlow.js也支持WebGL，因此即使在浏览器上，我们也能使用GPU来加速运算结果，不用担心在浏览器上的性能限制。\nTensorFlow.js分成低阶与高阶两组API。\n低阶的API是由 deeplearn.js 衍生，负责处理一些低阶如线性代数的数据运算等等，来协助我们处理机器学习中的数学运算部分。\n而高阶的API则是用来包装一些常用的机器学习演算法，同时允许我们载入训练好的模型，像是由Keras学习的模型等等。\n\n## 机器学习基本概念\n\n先来简单讲讲一般机器学习是怎么做的，在机器学习中，通常我们会针对一个题目，给予一组学习数据清单，这些数据包含了问题与答案，接着通过机器学习的各种算法，来训练出一个针对这个题目的模型。\n这个模型通常就代表了一个公式，只要将题目带进去公式，就能够算出答案，而这个公式怎么来的呢？就是通过机器学习算法，这些算法通常会先随机产生一个公式(也就是模型)，接着将学习数据带进去计算出预测值，并与正确答案比较，并通过不断的调整模型内容，不断想办法降低预测值与正确答案的差距，直到预测值与足够接近正确答案为止。\n简单来说，就是经验法则啦！刚开始学一项知识的时候，得到的结果会与预期落差很大，借由不断学到正确知识后，就会与预期越来越接近！\n","source":"_posts/机器学习.md","raw":"---\ntitle: 机器学习\ndate: 2021-04-14 15:12:59\ntags: 机器学习\n---\n## 什么是机器学习\n\n你可能每天用到它许多次却不知道它。 每次你用谷歌或者必应搜索，它们很好用 是因为它们的机器学习软件已经计算出如何对网页排名 脸书或者苹果的照片应用在照片中识别出你的朋友， 这也是机器学习。 每次你阅读你的邮件 垃圾邮件过滤器把你从海量的垃圾邮件中解救出来， 这也是因为你的计算机学习了如何从非垃圾邮件中辨别垃圾邮件。 这就是机器学习。 这是一门是让计算机 无需显式编程 (explicitly programmed) 就能自主学习的学科。 我正在做的其中一个研究项目是让机器人去 整理房间。 你要怎样去做这个？ 你能做的是使机器人看你的演示任务和 从中学习。 机器人会看你拿起了什么东西，放在了哪里 试着去做同样的事情，即使在你不在的时候。 我对此感到兴奋的原因之一是 AI ，即 人工智能问题。 建立真正的智能机器， 就可以做任何你和我也能做的事情。 许多科学家认为在这方面取得进展的最好方法 是通过一种叫做神经网络的学习算法 这种算法模仿人类大脑的工作过程， 之后我也会教你。\n\n## TensorFlow.js\n\nTensorFlow.js 是Google将机器学习(Machine Learning)TensorFlow框架的JavaScript版本，通过TensorFlow.js，让JavaScript开发人员也有机会加入机器学习的领域。加上前端领域的生态圈支持，让机器学习在浏览器上有了更多发挥的空间！例如结合摄影机、移动设备的陀螺仪等等，只要设备与浏览器支援，都能够发生更多不同的变化，同时借由在客户端浏览器上执行的优势，节省后端学习的成本。\n\n## TensorFlow.js的特色与基本组成\n\n由于TensorFlow.js是由JavaScript编写而成，因此只要与浏览器相关的应用，都可以与TensorFlow.js直接整合，这意味着我们可以将浏览器功能与机器学习搭配起来，组合成更多元的Web Application。\nTensorFlow.js也支持WebGL，因此即使在浏览器上，我们也能使用GPU来加速运算结果，不用担心在浏览器上的性能限制。\nTensorFlow.js分成低阶与高阶两组API。\n低阶的API是由 deeplearn.js 衍生，负责处理一些低阶如线性代数的数据运算等等，来协助我们处理机器学习中的数学运算部分。\n而高阶的API则是用来包装一些常用的机器学习演算法，同时允许我们载入训练好的模型，像是由Keras学习的模型等等。\n\n## 机器学习基本概念\n\n先来简单讲讲一般机器学习是怎么做的，在机器学习中，通常我们会针对一个题目，给予一组学习数据清单，这些数据包含了问题与答案，接着通过机器学习的各种算法，来训练出一个针对这个题目的模型。\n这个模型通常就代表了一个公式，只要将题目带进去公式，就能够算出答案，而这个公式怎么来的呢？就是通过机器学习算法，这些算法通常会先随机产生一个公式(也就是模型)，接着将学习数据带进去计算出预测值，并与正确答案比较，并通过不断的调整模型内容，不断想办法降低预测值与正确答案的差距，直到预测值与足够接近正确答案为止。\n简单来说，就是经验法则啦！刚开始学一项知识的时候，得到的结果会与预期落差很大，借由不断学到正确知识后，就会与预期越来越接近！\n","slug":"机器学习","published":1,"updated":"2021-04-23T06:45:08.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvl0008sgcm7ap5879r","content":"<h2 id=\"什么是机器学习\"><a href=\"#什么是机器学习\" class=\"headerlink\" title=\"什么是机器学习\"></a>什么是机器学习</h2><p>你可能每天用到它许多次却不知道它。 每次你用谷歌或者必应搜索，它们很好用 是因为它们的机器学习软件已经计算出如何对网页排名 脸书或者苹果的照片应用在照片中识别出你的朋友， 这也是机器学习。 每次你阅读你的邮件 垃圾邮件过滤器把你从海量的垃圾邮件中解救出来， 这也是因为你的计算机学习了如何从非垃圾邮件中辨别垃圾邮件。 这就是机器学习。 这是一门是让计算机 无需显式编程 (explicitly programmed) 就能自主学习的学科。 我正在做的其中一个研究项目是让机器人去 整理房间。 你要怎样去做这个？ 你能做的是使机器人看你的演示任务和 从中学习。 机器人会看你拿起了什么东西，放在了哪里 试着去做同样的事情，即使在你不在的时候。 我对此感到兴奋的原因之一是 AI ，即 人工智能问题。 建立真正的智能机器， 就可以做任何你和我也能做的事情。 许多科学家认为在这方面取得进展的最好方法 是通过一种叫做神经网络的学习算法 这种算法模仿人类大脑的工作过程， 之后我也会教你。</p>\n<h2 id=\"TensorFlow-js\"><a href=\"#TensorFlow-js\" class=\"headerlink\" title=\"TensorFlow.js\"></a>TensorFlow.js</h2><p>TensorFlow.js 是Google将机器学习(Machine Learning)TensorFlow框架的JavaScript版本，通过TensorFlow.js，让JavaScript开发人员也有机会加入机器学习的领域。加上前端领域的生态圈支持，让机器学习在浏览器上有了更多发挥的空间！例如结合摄影机、移动设备的陀螺仪等等，只要设备与浏览器支援，都能够发生更多不同的变化，同时借由在客户端浏览器上执行的优势，节省后端学习的成本。</p>\n<h2 id=\"TensorFlow-js的特色与基本组成\"><a href=\"#TensorFlow-js的特色与基本组成\" class=\"headerlink\" title=\"TensorFlow.js的特色与基本组成\"></a>TensorFlow.js的特色与基本组成</h2><p>由于TensorFlow.js是由JavaScript编写而成，因此只要与浏览器相关的应用，都可以与TensorFlow.js直接整合，这意味着我们可以将浏览器功能与机器学习搭配起来，组合成更多元的Web Application。<br>TensorFlow.js也支持WebGL，因此即使在浏览器上，我们也能使用GPU来加速运算结果，不用担心在浏览器上的性能限制。<br>TensorFlow.js分成低阶与高阶两组API。<br>低阶的API是由 deeplearn.js 衍生，负责处理一些低阶如线性代数的数据运算等等，来协助我们处理机器学习中的数学运算部分。<br>而高阶的API则是用来包装一些常用的机器学习演算法，同时允许我们载入训练好的模型，像是由Keras学习的模型等等。</p>\n<h2 id=\"机器学习基本概念\"><a href=\"#机器学习基本概念\" class=\"headerlink\" title=\"机器学习基本概念\"></a>机器学习基本概念</h2><p>先来简单讲讲一般机器学习是怎么做的，在机器学习中，通常我们会针对一个题目，给予一组学习数据清单，这些数据包含了问题与答案，接着通过机器学习的各种算法，来训练出一个针对这个题目的模型。<br>这个模型通常就代表了一个公式，只要将题目带进去公式，就能够算出答案，而这个公式怎么来的呢？就是通过机器学习算法，这些算法通常会先随机产生一个公式(也就是模型)，接着将学习数据带进去计算出预测值，并与正确答案比较，并通过不断的调整模型内容，不断想办法降低预测值与正确答案的差距，直到预测值与足够接近正确答案为止。<br>简单来说，就是经验法则啦！刚开始学一项知识的时候，得到的结果会与预期落差很大，借由不断学到正确知识后，就会与预期越来越接近！</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"什么是机器学习\"><a href=\"#什么是机器学习\" class=\"headerlink\" title=\"什么是机器学习\"></a>什么是机器学习</h2><p>你可能每天用到它许多次却不知道它。 每次你用谷歌或者必应搜索，它们很好用 是因为它们的机器学习软件已经计算出如何对网页排名 脸书或者苹果的照片应用在照片中识别出你的朋友， 这也是机器学习。 每次你阅读你的邮件 垃圾邮件过滤器把你从海量的垃圾邮件中解救出来， 这也是因为你的计算机学习了如何从非垃圾邮件中辨别垃圾邮件。 这就是机器学习。 这是一门是让计算机 无需显式编程 (explicitly programmed) 就能自主学习的学科。 我正在做的其中一个研究项目是让机器人去 整理房间。 你要怎样去做这个？ 你能做的是使机器人看你的演示任务和 从中学习。 机器人会看你拿起了什么东西，放在了哪里 试着去做同样的事情，即使在你不在的时候。 我对此感到兴奋的原因之一是 AI ，即 人工智能问题。 建立真正的智能机器， 就可以做任何你和我也能做的事情。 许多科学家认为在这方面取得进展的最好方法 是通过一种叫做神经网络的学习算法 这种算法模仿人类大脑的工作过程， 之后我也会教你。</p>\n<h2 id=\"TensorFlow-js\"><a href=\"#TensorFlow-js\" class=\"headerlink\" title=\"TensorFlow.js\"></a>TensorFlow.js</h2><p>TensorFlow.js 是Google将机器学习(Machine Learning)TensorFlow框架的JavaScript版本，通过TensorFlow.js，让JavaScript开发人员也有机会加入机器学习的领域。加上前端领域的生态圈支持，让机器学习在浏览器上有了更多发挥的空间！例如结合摄影机、移动设备的陀螺仪等等，只要设备与浏览器支援，都能够发生更多不同的变化，同时借由在客户端浏览器上执行的优势，节省后端学习的成本。</p>\n<h2 id=\"TensorFlow-js的特色与基本组成\"><a href=\"#TensorFlow-js的特色与基本组成\" class=\"headerlink\" title=\"TensorFlow.js的特色与基本组成\"></a>TensorFlow.js的特色与基本组成</h2><p>由于TensorFlow.js是由JavaScript编写而成，因此只要与浏览器相关的应用，都可以与TensorFlow.js直接整合，这意味着我们可以将浏览器功能与机器学习搭配起来，组合成更多元的Web Application。<br>TensorFlow.js也支持WebGL，因此即使在浏览器上，我们也能使用GPU来加速运算结果，不用担心在浏览器上的性能限制。<br>TensorFlow.js分成低阶与高阶两组API。<br>低阶的API是由 deeplearn.js 衍生，负责处理一些低阶如线性代数的数据运算等等，来协助我们处理机器学习中的数学运算部分。<br>而高阶的API则是用来包装一些常用的机器学习演算法，同时允许我们载入训练好的模型，像是由Keras学习的模型等等。</p>\n<h2 id=\"机器学习基本概念\"><a href=\"#机器学习基本概念\" class=\"headerlink\" title=\"机器学习基本概念\"></a>机器学习基本概念</h2><p>先来简单讲讲一般机器学习是怎么做的，在机器学习中，通常我们会针对一个题目，给予一组学习数据清单，这些数据包含了问题与答案，接着通过机器学习的各种算法，来训练出一个针对这个题目的模型。<br>这个模型通常就代表了一个公式，只要将题目带进去公式，就能够算出答案，而这个公式怎么来的呢？就是通过机器学习算法，这些算法通常会先随机产生一个公式(也就是模型)，接着将学习数据带进去计算出预测值，并与正确答案比较，并通过不断的调整模型内容，不断想办法降低预测值与正确答案的差距，直到预测值与足够接近正确答案为止。<br>简单来说，就是经验法则啦！刚开始学一项知识的时候，得到的结果会与预期落差很大，借由不断学到正确知识后，就会与预期越来越接近！</p>\n"},{"title":"算法题2","date":"2021-04-21T12:04:53.000Z","_content":"## 题目 （简单）\n\n替换空格\n\n请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20\nAre%20Happy\n\n## 思路\n\n1.将字符串转换为数组，统计其中的空格数量\n\n2.根据空格数量和原有长度计算出替换后的字符长度数组\n\n3.创建2个指针，一个指末尾，一个指字符串有效位末尾，实现原地修改\n\n数组遍历从后往前遍历，避免从前往后，造成字符串被修改\n\n## 代码\n\n```\nvar replaceSpace = function (s) {\n    s = s.split(\"\");\n    let oldLen = s.length;\n    let spaceCount = 0;\n    for(let i=0;i< oldLen; i++){\n        if(s[i]===' '){\n            spaceCount++;\n        }\n    }\n    s.length += spaceCount * 2;\n    for (let i = oldLen-1,j=s.length-1;i>=0;i--,j--){\n        if(s[i] !== ' ') s[j] = s[i];\n        else {\n            s[j-2]='%';\n            s[j-1]='2';\n            s[j]='0';\n            j-=2;\n        }\n    }\n    return s.join('')\n}\n```","source":"_posts/算法题2.md","raw":"---\ntitle: 算法题2\ndate: 2021-04-21 20:04:53\ntags: 算法\ncategories: 每日一题\n---\n## 题目 （简单）\n\n替换空格\n\n请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20\nAre%20Happy\n\n## 思路\n\n1.将字符串转换为数组，统计其中的空格数量\n\n2.根据空格数量和原有长度计算出替换后的字符长度数组\n\n3.创建2个指针，一个指末尾，一个指字符串有效位末尾，实现原地修改\n\n数组遍历从后往前遍历，避免从前往后，造成字符串被修改\n\n## 代码\n\n```\nvar replaceSpace = function (s) {\n    s = s.split(\"\");\n    let oldLen = s.length;\n    let spaceCount = 0;\n    for(let i=0;i< oldLen; i++){\n        if(s[i]===' '){\n            spaceCount++;\n        }\n    }\n    s.length += spaceCount * 2;\n    for (let i = oldLen-1,j=s.length-1;i>=0;i--,j--){\n        if(s[i] !== ' ') s[j] = s[i];\n        else {\n            s[j-2]='%';\n            s[j-1]='2';\n            s[j]='0';\n            j-=2;\n        }\n    }\n    return s.join('')\n}\n```","slug":"算法题2","published":1,"updated":"2021-04-23T06:45:08.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvn000csgcmc1klfg0p","content":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>替换空格</p>\n<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20<br>Are%20Happy</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>1.将字符串转换为数组，统计其中的空格数量</p>\n<p>2.根据空格数量和原有长度计算出替换后的字符长度数组</p>\n<p>3.创建2个指针，一个指末尾，一个指字符串有效位末尾，实现原地修改</p>\n<p>数组遍历从后往前遍历，避免从前往后，造成字符串被修改</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var replaceSpace &#x3D; function (s) &#123;</span><br><span class=\"line\">    s &#x3D; s.split(&quot;&quot;);</span><br><span class=\"line\">    let oldLen &#x3D; s.length;</span><br><span class=\"line\">    let spaceCount &#x3D; 0;</span><br><span class=\"line\">    for(let i&#x3D;0;i&lt; oldLen; i++)&#123;</span><br><span class=\"line\">        if(s[i]&#x3D;&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class=\"line\">            spaceCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.length +&#x3D; spaceCount * 2;</span><br><span class=\"line\">    for (let i &#x3D; oldLen-1,j&#x3D;s.length-1;i&gt;&#x3D;0;i--,j--)&#123;</span><br><span class=\"line\">        if(s[i] !&#x3D;&#x3D; &#39; &#39;) s[j] &#x3D; s[i];</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            s[j-2]&#x3D;&#39;%&#39;;</span><br><span class=\"line\">            s[j-1]&#x3D;&#39;2&#39;;</span><br><span class=\"line\">            s[j]&#x3D;&#39;0&#39;;</span><br><span class=\"line\">            j-&#x3D;2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return s.join(&#39;&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>替换空格</p>\n<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20<br>Are%20Happy</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>1.将字符串转换为数组，统计其中的空格数量</p>\n<p>2.根据空格数量和原有长度计算出替换后的字符长度数组</p>\n<p>3.创建2个指针，一个指末尾，一个指字符串有效位末尾，实现原地修改</p>\n<p>数组遍历从后往前遍历，避免从前往后，造成字符串被修改</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var replaceSpace &#x3D; function (s) &#123;</span><br><span class=\"line\">    s &#x3D; s.split(&quot;&quot;);</span><br><span class=\"line\">    let oldLen &#x3D; s.length;</span><br><span class=\"line\">    let spaceCount &#x3D; 0;</span><br><span class=\"line\">    for(let i&#x3D;0;i&lt; oldLen; i++)&#123;</span><br><span class=\"line\">        if(s[i]&#x3D;&#x3D;&#x3D;&#39; &#39;)&#123;</span><br><span class=\"line\">            spaceCount++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    s.length +&#x3D; spaceCount * 2;</span><br><span class=\"line\">    for (let i &#x3D; oldLen-1,j&#x3D;s.length-1;i&gt;&#x3D;0;i--,j--)&#123;</span><br><span class=\"line\">        if(s[i] !&#x3D;&#x3D; &#39; &#39;) s[j] &#x3D; s[i];</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            s[j-2]&#x3D;&#39;%&#39;;</span><br><span class=\"line\">            s[j-1]&#x3D;&#39;2&#39;;</span><br><span class=\"line\">            s[j]&#x3D;&#39;0&#39;;</span><br><span class=\"line\">            j-&#x3D;2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return s.join(&#39;&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"算法题3","date":"2021-04-22T12:27:46.000Z","_content":"## 题目 （简单）\n\n跳台阶\n\n一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n## 思路\n\n跳台阶是动态规划问题，由于一次只能跳1级或者2级，因此跳上n级台阶一共有2种方案，一种是从n-2跳上，一种是从n-1跳上\n\n## 代码\n\n方法一\n```\nvar numWays = function (n) {\n    if(n<=1) return 1;\n    if(n===2) return 2;\n    return (numWays(n-1)+numWays(n-2))\n}\n```\n方法二\n```\nvar numWays = function (n) {\n    let p=0,c=1;\n    while (n--) [p,c] = [c,(p+c)]\n    return c\n}\n```\n方法三\n```\nvar numWays = function(n) { \n    let dp = [];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n      let c = dp[i - 1] + dp[i - 2];\n      dp[i] = c ;\n    }\n    return dp[n]\n}\n```","source":"_posts/算法题3.md","raw":"---\ntitle: 算法题3\ndate: 2021-04-22 20:27:46\ntags: 算法\ncategories: 每日一题\n---\n## 题目 （简单）\n\n跳台阶\n\n一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\n\n## 思路\n\n跳台阶是动态规划问题，由于一次只能跳1级或者2级，因此跳上n级台阶一共有2种方案，一种是从n-2跳上，一种是从n-1跳上\n\n## 代码\n\n方法一\n```\nvar numWays = function (n) {\n    if(n<=1) return 1;\n    if(n===2) return 2;\n    return (numWays(n-1)+numWays(n-2))\n}\n```\n方法二\n```\nvar numWays = function (n) {\n    let p=0,c=1;\n    while (n--) [p,c] = [c,(p+c)]\n    return c\n}\n```\n方法三\n```\nvar numWays = function(n) { \n    let dp = [];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n      let c = dp[i - 1] + dp[i - 2];\n      dp[i] = c ;\n    }\n    return dp[n]\n}\n```","slug":"算法题3","published":1,"updated":"2021-04-23T06:45:08.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvo000dsgcm48ek2b1t","content":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>跳台阶</p>\n<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>跳台阶是动态规划问题，由于一次只能跳1级或者2级，因此跳上n级台阶一共有2种方案，一种是从n-2跳上，一种是从n-1跳上</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numWays &#x3D; function (n) &#123;</span><br><span class=\"line\">    if(n&lt;&#x3D;1) return 1;</span><br><span class=\"line\">    if(n&#x3D;&#x3D;&#x3D;2) return 2;</span><br><span class=\"line\">    return (numWays(n-1)+numWays(n-2))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numWays &#x3D; function (n) &#123;</span><br><span class=\"line\">    let p&#x3D;0,c&#x3D;1;</span><br><span class=\"line\">    while (n--) [p,c] &#x3D; [c,(p+c)]</span><br><span class=\"line\">    return c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法三</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numWays &#x3D; function(n) &#123; </span><br><span class=\"line\">    let dp &#x3D; [];</span><br><span class=\"line\">    dp[0] &#x3D; 1;</span><br><span class=\"line\">    dp[1] &#x3D; 1;</span><br><span class=\"line\">    for (let i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class=\"line\">      let c &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class=\"line\">      dp[i] &#x3D; c ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dp[n]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>跳台阶</p>\n<p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>跳台阶是动态规划问题，由于一次只能跳1级或者2级，因此跳上n级台阶一共有2种方案，一种是从n-2跳上，一种是从n-1跳上</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numWays &#x3D; function (n) &#123;</span><br><span class=\"line\">    if(n&lt;&#x3D;1) return 1;</span><br><span class=\"line\">    if(n&#x3D;&#x3D;&#x3D;2) return 2;</span><br><span class=\"line\">    return (numWays(n-1)+numWays(n-2))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numWays &#x3D; function (n) &#123;</span><br><span class=\"line\">    let p&#x3D;0,c&#x3D;1;</span><br><span class=\"line\">    while (n--) [p,c] &#x3D; [c,(p+c)]</span><br><span class=\"line\">    return c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法三</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var numWays &#x3D; function(n) &#123; </span><br><span class=\"line\">    let dp &#x3D; [];</span><br><span class=\"line\">    dp[0] &#x3D; 1;</span><br><span class=\"line\">    dp[1] &#x3D; 1;</span><br><span class=\"line\">    for (let i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;</span><br><span class=\"line\">      let c &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class=\"line\">      dp[i] &#x3D; c ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return dp[n]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"算法题4","date":"2021-04-23T12:14:25.000Z","_content":"## 题目 （简单）\n\n二进制中 1 的个数\n\n输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。\n\n## 思路\n\n一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后\n面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判\n断这个数可以经历多少次这样的过程\n\n## 代码\n\n方法一\n```\nvar hammingWeight = function (n) {\n    let count = 0;\n    while(n){\n        count++;\n        n= n & (n-1)\n    }\n    return count\n}\n```\n","source":"_posts/算法题4.md","raw":"---\ntitle: 算法题4\ndate: 2021-04-23 20:14:25\ntags: 算法\ncategories: 每日一题\n---\n## 题目 （简单）\n\n二进制中 1 的个数\n\n输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。\n\n## 思路\n\n一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后\n面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判\n断这个数可以经历多少次这样的过程\n\n## 代码\n\n方法一\n```\nvar hammingWeight = function (n) {\n    let count = 0;\n    while(n){\n        count++;\n        n= n & (n-1)\n    }\n    return count\n}\n```\n","slug":"算法题4","published":1,"updated":"2021-04-23T12:38:35.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvp000gsgcm3xim6n7a","content":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>二进制中 1 的个数</p>\n<p>输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后<br>面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判<br>断这个数可以经历多少次这样的过程</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hammingWeight &#x3D; function (n) &#123;</span><br><span class=\"line\">    let count &#x3D; 0;</span><br><span class=\"line\">    while(n)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        n&#x3D; n &amp; (n-1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>二进制中 1 的个数</p>\n<p>输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后<br>面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判<br>断这个数可以经历多少次这样的过程</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var hammingWeight &#x3D; function (n) &#123;</span><br><span class=\"line\">    let count &#x3D; 0;</span><br><span class=\"line\">    while(n)&#123;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        n&#x3D; n &amp; (n-1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"算法题5","date":"2021-04-25T12:11:24.000Z","_content":"\n## 题目 （简单）\n\n调整数组顺序使奇数位于偶数前面\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半\n部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n## 思路\n\n一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后\n面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判\n断这个数可以经历多少次这样的过程\n\n## 代码\n\n方法一\n```\n/**\n * @format\n * @param {number[]} nums\n * @return {number[]}\n */\n\n// 不用看双指针  数组问题基本要想到双指针\n// 双指针解法可以优化空间和时间 原地\nvar exchange = function (nums) {\n let front = 0\n let after = 0\n for (let i = 0; i < nums.length; i++) {\n  // 证明是偶数\n  if (nums[after] % 2 === 0 && front < nums.length) {\n   while (nums[front] % 2 === 0) {\n    front++\n   }\n   if (front < nums.length) {\n    // 交换\n    let temp = nums[front]\n    nums[front] = nums[after]\n    nums[after] = temp\n   }\n  }\n  after++\n  front++\n }\n return nums\n}\n\n\n```\n\n方法二\n```\nvar exchange = function(nums) {\n    return nums.sort((a,b)=>b%2-a%2)\n};\n\n```\n","source":"_posts/算法题5.md","raw":"---\ntitle: 算法题5\ndate: 2021-04-25 20:11:24\ntags: 算法\ncategories: 每日一题\n---\n\n## 题目 （简单）\n\n调整数组顺序使奇数位于偶数前面\n\n输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半\n部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。\n\n## 思路\n\n一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后\n面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判\n断这个数可以经历多少次这样的过程\n\n## 代码\n\n方法一\n```\n/**\n * @format\n * @param {number[]} nums\n * @return {number[]}\n */\n\n// 不用看双指针  数组问题基本要想到双指针\n// 双指针解法可以优化空间和时间 原地\nvar exchange = function (nums) {\n let front = 0\n let after = 0\n for (let i = 0; i < nums.length; i++) {\n  // 证明是偶数\n  if (nums[after] % 2 === 0 && front < nums.length) {\n   while (nums[front] % 2 === 0) {\n    front++\n   }\n   if (front < nums.length) {\n    // 交换\n    let temp = nums[front]\n    nums[front] = nums[after]\n    nums[after] = temp\n   }\n  }\n  after++\n  front++\n }\n return nums\n}\n\n\n```\n\n方法二\n```\nvar exchange = function(nums) {\n    return nums.sort((a,b)=>b%2-a%2)\n};\n\n```\n","slug":"算法题5","published":1,"updated":"2021-04-25T12:40:59.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvr000jsgcm0ajoe3m2","content":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>调整数组顺序使奇数位于偶数前面</p>\n<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半<br>部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后<br>面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判<br>断这个数可以经历多少次这样的过程</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @format</span><br><span class=\"line\"> * @param &#123;number[]&#125; nums</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不用看双指针  数组问题基本要想到双指针</span><br><span class=\"line\">&#x2F;&#x2F; 双指针解法可以优化空间和时间 原地</span><br><span class=\"line\">var exchange &#x3D; function (nums) &#123;</span><br><span class=\"line\"> let front &#x3D; 0</span><br><span class=\"line\"> let after &#x3D; 0</span><br><span class=\"line\"> for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 证明是偶数</span><br><span class=\"line\">  if (nums[after] % 2 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; front &lt; nums.length) &#123;</span><br><span class=\"line\">   while (nums[front] % 2 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">    front++</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   if (front &lt; nums.length) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 交换</span><br><span class=\"line\">    let temp &#x3D; nums[front]</span><br><span class=\"line\">    nums[front] &#x3D; nums[after]</span><br><span class=\"line\">    nums[after] &#x3D; temp</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  after++</span><br><span class=\"line\">  front++</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return nums</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>方法二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var exchange &#x3D; function(nums) &#123;</span><br><span class=\"line\">    return nums.sort((a,b)&#x3D;&gt;b%2-a%2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"题目-（简单）\"><a href=\"#题目-（简单）\" class=\"headerlink\" title=\"题目 （简单）\"></a>题目 （简单）</h2><p>调整数组顺序使奇数位于偶数前面</p>\n<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半<br>部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>一个不为 0 的整数的二进制表示，一定会有一位为 1。我们找到最右边的一位 1，当我们将整数减去 1 时，最右边的一位 1 变为 0，它后<br>面的所有位都取反，因此将减一后的值与原值相与，我们就会能够消除最右边的一位 1。因此判断一个二进制中 1 的个数，我们可以判<br>断这个数可以经历多少次这样的过程</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @format</span><br><span class=\"line\"> * @param &#123;number[]&#125; nums</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不用看双指针  数组问题基本要想到双指针</span><br><span class=\"line\">&#x2F;&#x2F; 双指针解法可以优化空间和时间 原地</span><br><span class=\"line\">var exchange &#x3D; function (nums) &#123;</span><br><span class=\"line\"> let front &#x3D; 0</span><br><span class=\"line\"> let after &#x3D; 0</span><br><span class=\"line\"> for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; 证明是偶数</span><br><span class=\"line\">  if (nums[after] % 2 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; front &lt; nums.length) &#123;</span><br><span class=\"line\">   while (nums[front] % 2 &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class=\"line\">    front++</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   if (front &lt; nums.length) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 交换</span><br><span class=\"line\">    let temp &#x3D; nums[front]</span><br><span class=\"line\">    nums[front] &#x3D; nums[after]</span><br><span class=\"line\">    nums[after] &#x3D; temp</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  after++</span><br><span class=\"line\">  front++</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> return nums</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>方法二</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var exchange &#x3D; function(nums) &#123;</span><br><span class=\"line\">    return nums.sort((a,b)&#x3D;&gt;b%2-a%2)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"算法题6","date":"2021-04-27T12:15:45.000Z","_content":"## 题目 （困难）\n\n整数中 1 出现的次数\n\n求出 1~13 的整数中 1 出现的次数，并算出 100~1# 300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、\n12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整\n数区间中 1 出现的次数。\n\n## 思路\n\n这种题就要找规律，与之前做的那道找某个位置是什么数字的类似\n现在有一个函数f(n)，代表n位上有多少个1\n        f(0) = 0\n 0~9    f(1) = 1\n 0~99   f(2) = 10 + 10*f(1) = 20  (10+为  10~19中十位有10个1)\n 0~999  f(3) = 100 + 10*f(2) = 300  (100+为  100~199中百位有100个1)\n 10~9999 f(4) = 1000 + 10*f(3) = 4000 (...)\n...\n如 5467 中有多少个1\n1. 0~5000中有 5 * f(3) + 1000 = 2500个\n2. 0~400中有 4 * f(2) + 100 = 180个\n3. 0~60中有 6 * f(1) + 10 = 16个\n4. 0~7中有 7 * f(0) + 1 = 1个\n所以5467中有2697个1\n\n## 代码\n\n方法一\n```\n/**\n * @param {number} n\n * @return {number}\n */\nvar countDigitOne = function(n) {\n    let f = [0,1,20,300,4000,50000,600000,7000000,80000000,900000000,10000000000];\n    let res = 0;\n    let str = n + '';\n    const len = str.length;\n    let m = Math.pow(10,len - 1);\n    let p = len - 1; //解析中的n\n    for(let i = 0; i < len; i++) {\n        res += str[i] * f[p];\n        if(str[i] === '1' && i !== len - 1) {//中间为1时后面的每一个数都要加一个1，再加上第一个1，比如12中10，11,12三个数的十位有3个1，需要加上，也就是2+1个1要加上\n         res += Number(str.slice(i + 1)) + 1;\n        } else if(str[i] === '1' && i === len - 1) {//解决末尾为1但未加上的bug\n         res += 1;\n        }\n        if(str[i] > 1) res += m;\n        m /= 10, p -=1;\n    }\n    return res;\n};\n\n\n\n```","source":"_posts/算法题6.md","raw":"---\ntitle: 算法题6\ndate: 2021-04-27 20:15:45\ntags: 算法\ncategories: 每日一题\n---\n## 题目 （困难）\n\n整数中 1 出现的次数\n\n求出 1~13 的整数中 1 出现的次数，并算出 100~1# 300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、\n12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整\n数区间中 1 出现的次数。\n\n## 思路\n\n这种题就要找规律，与之前做的那道找某个位置是什么数字的类似\n现在有一个函数f(n)，代表n位上有多少个1\n        f(0) = 0\n 0~9    f(1) = 1\n 0~99   f(2) = 10 + 10*f(1) = 20  (10+为  10~19中十位有10个1)\n 0~999  f(3) = 100 + 10*f(2) = 300  (100+为  100~199中百位有100个1)\n 10~9999 f(4) = 1000 + 10*f(3) = 4000 (...)\n...\n如 5467 中有多少个1\n1. 0~5000中有 5 * f(3) + 1000 = 2500个\n2. 0~400中有 4 * f(2) + 100 = 180个\n3. 0~60中有 6 * f(1) + 10 = 16个\n4. 0~7中有 7 * f(0) + 1 = 1个\n所以5467中有2697个1\n\n## 代码\n\n方法一\n```\n/**\n * @param {number} n\n * @return {number}\n */\nvar countDigitOne = function(n) {\n    let f = [0,1,20,300,4000,50000,600000,7000000,80000000,900000000,10000000000];\n    let res = 0;\n    let str = n + '';\n    const len = str.length;\n    let m = Math.pow(10,len - 1);\n    let p = len - 1; //解析中的n\n    for(let i = 0; i < len; i++) {\n        res += str[i] * f[p];\n        if(str[i] === '1' && i !== len - 1) {//中间为1时后面的每一个数都要加一个1，再加上第一个1，比如12中10，11,12三个数的十位有3个1，需要加上，也就是2+1个1要加上\n         res += Number(str.slice(i + 1)) + 1;\n        } else if(str[i] === '1' && i === len - 1) {//解决末尾为1但未加上的bug\n         res += 1;\n        }\n        if(str[i] > 1) res += m;\n        m /= 10, p -=1;\n    }\n    return res;\n};\n\n\n\n```","slug":"算法题6","published":1,"updated":"2021-04-27T12:43:56.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cko018yvs000lsgcm2h0g9rbz","content":"<h2 id=\"题目-（困难）\"><a href=\"#题目-（困难）\" class=\"headerlink\" title=\"题目 （困难）\"></a>题目 （困难）</h2><p>整数中 1 出现的次数</p>\n<p>求出 1<del>13 的整数中 1 出现的次数，并算出 100</del>1# 300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、<br>12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整<br>数区间中 1 出现的次数。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这种题就要找规律，与之前做的那道找某个位置是什么数字的类似<br>现在有一个函数f(n)，代表n位上有多少个1<br>        f(0) = 0<br> 0<del>9    f(1) = 1<br> 0</del>99   f(2) = 10 + 10<em>f(1) = 20  (10+为  10<del>19中十位有10个1)<br> 0</del>999  f(3) = 100 + 10</em>f(2) = 300  (100+为  100<del>199中百位有100个1)<br> 10</del>9999 f(4) = 1000 + 10*f(3) = 4000 (…)<br>…<br>如 5467 中有多少个1</p>\n<ol>\n<li>0~5000中有 5 * f(3) + 1000 = 2500个</li>\n<li>0~400中有 4 * f(2) + 100 = 180个</li>\n<li>0~60中有 6 * f(1) + 10 = 16个</li>\n<li>0~7中有 7 * f(0) + 1 = 1个<br>所以5467中有2697个1</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @param &#123;number&#125; n</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">var countDigitOne &#x3D; function(n) &#123;</span><br><span class=\"line\">    let f &#x3D; [0,1,20,300,4000,50000,600000,7000000,80000000,900000000,10000000000];</span><br><span class=\"line\">    let res &#x3D; 0;</span><br><span class=\"line\">    let str &#x3D; n + &#39;&#39;;</span><br><span class=\"line\">    const len &#x3D; str.length;</span><br><span class=\"line\">    let m &#x3D; Math.pow(10,len - 1);</span><br><span class=\"line\">    let p &#x3D; len - 1; &#x2F;&#x2F;解析中的n</span><br><span class=\"line\">    for(let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        res +&#x3D; str[i] * f[p];</span><br><span class=\"line\">        if(str[i] &#x3D;&#x3D;&#x3D; &#39;1&#39; &amp;&amp; i !&#x3D;&#x3D; len - 1) &#123;&#x2F;&#x2F;中间为1时后面的每一个数都要加一个1，再加上第一个1，比如12中10，11,12三个数的十位有3个1，需要加上，也就是2+1个1要加上</span><br><span class=\"line\">         res +&#x3D; Number(str.slice(i + 1)) + 1;</span><br><span class=\"line\">        &#125; else if(str[i] &#x3D;&#x3D;&#x3D; &#39;1&#39; &amp;&amp; i &#x3D;&#x3D;&#x3D; len - 1) &#123;&#x2F;&#x2F;解决末尾为1但未加上的bug</span><br><span class=\"line\">         res +&#x3D; 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(str[i] &gt; 1) res +&#x3D; m;</span><br><span class=\"line\">        m &#x2F;&#x3D; 10, p -&#x3D;1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"题目-（困难）\"><a href=\"#题目-（困难）\" class=\"headerlink\" title=\"题目 （困难）\"></a>题目 （困难）</h2><p>整数中 1 出现的次数</p>\n<p>求出 1<del>13 的整数中 1 出现的次数，并算出 100</del>1# 300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、<br>12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整<br>数区间中 1 出现的次数。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>这种题就要找规律，与之前做的那道找某个位置是什么数字的类似<br>现在有一个函数f(n)，代表n位上有多少个1<br>        f(0) = 0<br> 0<del>9    f(1) = 1<br> 0</del>99   f(2) = 10 + 10<em>f(1) = 20  (10+为  10<del>19中十位有10个1)<br> 0</del>999  f(3) = 100 + 10</em>f(2) = 300  (100+为  100<del>199中百位有100个1)<br> 10</del>9999 f(4) = 1000 + 10*f(3) = 4000 (…)<br>…<br>如 5467 中有多少个1</p>\n<ol>\n<li>0~5000中有 5 * f(3) + 1000 = 2500个</li>\n<li>0~400中有 4 * f(2) + 100 = 180个</li>\n<li>0~60中有 6 * f(1) + 10 = 16个</li>\n<li>0~7中有 7 * f(0) + 1 = 1个<br>所以5467中有2697个1</li>\n</ol>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><p>方法一</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @param &#123;number&#125; n</span><br><span class=\"line\"> * @return &#123;number&#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">var countDigitOne &#x3D; function(n) &#123;</span><br><span class=\"line\">    let f &#x3D; [0,1,20,300,4000,50000,600000,7000000,80000000,900000000,10000000000];</span><br><span class=\"line\">    let res &#x3D; 0;</span><br><span class=\"line\">    let str &#x3D; n + &#39;&#39;;</span><br><span class=\"line\">    const len &#x3D; str.length;</span><br><span class=\"line\">    let m &#x3D; Math.pow(10,len - 1);</span><br><span class=\"line\">    let p &#x3D; len - 1; &#x2F;&#x2F;解析中的n</span><br><span class=\"line\">    for(let i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        res +&#x3D; str[i] * f[p];</span><br><span class=\"line\">        if(str[i] &#x3D;&#x3D;&#x3D; &#39;1&#39; &amp;&amp; i !&#x3D;&#x3D; len - 1) &#123;&#x2F;&#x2F;中间为1时后面的每一个数都要加一个1，再加上第一个1，比如12中10，11,12三个数的十位有3个1，需要加上，也就是2+1个1要加上</span><br><span class=\"line\">         res +&#x3D; Number(str.slice(i + 1)) + 1;</span><br><span class=\"line\">        &#125; else if(str[i] &#x3D;&#x3D;&#x3D; &#39;1&#39; &amp;&amp; i &#x3D;&#x3D;&#x3D; len - 1) &#123;&#x2F;&#x2F;解决末尾为1但未加上的bug</span><br><span class=\"line\">         res +&#x3D; 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(str[i] &gt; 1) res +&#x3D; m;</span><br><span class=\"line\">        m &#x2F;&#x3D; 10, p -&#x3D;1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cko018yvc0001sgcmdql2ft5s","category_id":"cko018yvh0004sgcmh3pd6jcg","_id":"cko018yvo000esgcmhzjj6yp3"},{"post_id":"cko018yvo000dsgcm48ek2b1t","category_id":"cko018yvm000asgcmd5o1eci4","_id":"cko018yvs000msgcmb2l0gghr"},{"post_id":"cko018yvk0007sgcm31q7eaj3","category_id":"cko018yvm000asgcmd5o1eci4","_id":"cko018yvt000osgcm436e1tr3"},{"post_id":"cko018yvp000gsgcm3xim6n7a","category_id":"cko018yvm000asgcmd5o1eci4","_id":"cko018yvt000rsgcmgd5dcifg"},{"post_id":"cko018yvr000jsgcm0ajoe3m2","category_id":"cko018yvm000asgcmd5o1eci4","_id":"cko018yvu000tsgcm3ig2f9e6"},{"post_id":"cko018yvn000csgcmc1klfg0p","category_id":"cko018yvm000asgcmd5o1eci4","_id":"cko018yvu000usgcmd52g7zre"},{"post_id":"cko018yvs000lsgcm2h0g9rbz","category_id":"cko018yvm000asgcmd5o1eci4","_id":"cko018yvu000xsgcmgy0g9mjz"}],"PostTag":[{"post_id":"cko018yvc0001sgcmdql2ft5s","tag_id":"cko018yvj0005sgcmg9upgr1i","_id":"cko018yvn000bsgcm9qkna82k"},{"post_id":"cko018yvf0003sgcm7wuv3anc","tag_id":"cko018yvm0009sgcm7e0m798x","_id":"cko018yvp000isgcm12q8a44y"},{"post_id":"cko018yvj0006sgcmau7fases","tag_id":"cko018yvo000fsgcm8rnh943t","_id":"cko018yvs000nsgcm4egcccos"},{"post_id":"cko018yvs000lsgcm2h0g9rbz","tag_id":"cko018yvr000ksgcmciwggnfx","_id":"cko018yvt000psgcmbaumbb82"},{"post_id":"cko018yvk0007sgcm31q7eaj3","tag_id":"cko018yvr000ksgcmciwggnfx","_id":"cko018yvt000ssgcmf94v6pzz"},{"post_id":"cko018yvl0008sgcm7ap5879r","tag_id":"cko018yvt000qsgcm3afq86mc","_id":"cko018yvu000wsgcm2bradm90"},{"post_id":"cko018yvn000csgcmc1klfg0p","tag_id":"cko018yvr000ksgcmciwggnfx","_id":"cko018yvv000zsgcmcuq77bts"},{"post_id":"cko018yvo000dsgcm48ek2b1t","tag_id":"cko018yvr000ksgcmciwggnfx","_id":"cko018yvv0011sgcmdot6btwv"},{"post_id":"cko018yvp000gsgcm3xim6n7a","tag_id":"cko018yvr000ksgcmciwggnfx","_id":"cko018yvw0013sgcm7xmucyhu"},{"post_id":"cko018yvr000jsgcm0ajoe3m2","tag_id":"cko018yvr000ksgcmciwggnfx","_id":"cko018yvw0014sgcmfkip8hb8"}],"Tag":[{"name":"Markdown","_id":"cko018yvj0005sgcmg9upgr1i"},{"name":"JS","_id":"cko018yvm0009sgcm7e0m798x"},{"name":"webpack","_id":"cko018yvo000fsgcm8rnh943t"},{"name":"算法","_id":"cko018yvr000ksgcmciwggnfx"},{"name":"机器学习","_id":"cko018yvt000qsgcm3afq86mc"}]}}